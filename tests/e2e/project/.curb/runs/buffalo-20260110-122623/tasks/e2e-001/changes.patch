diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl
index a0b31fd..9cf45c3 100644
--- a/.beads/issues.jsonl
+++ b/.beads/issues.jsonl
@@ -8,7 +8,7 @@
 {"id":"curb-008","title":"Write BATS tests for lib/session.sh","description":"## Context\nTest coverage ensures session management works correctly and catches regressions.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 25m\n**Approach:** Follow existing test patterns in tests/. Test both happy paths and error cases.\n\n## Implementation Steps\n1. Create tests/session.bats\n2. Test session_random_name returns valid animal\n3. Test session_init with no args\n4. Test session_init --name custom\n5. Test session_get_* functions return expected formats\n6. Test calling getters before init fails\n\n## Acceptance Criteria\n- [ ] tests/session.bats exists\n- [ ] All session functions have test coverage\n- [ ] Tests pass: bats tests/session.bats\n- [ ] Error cases are tested\n\n## Files Likely Involved\n- tests/session.bats (new)\n- lib/session.sh\n\n## Notes\nLook at existing tests for patterns. Use setup/teardown for test isolation.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-10T10:15:02.633149-05:00","updated_at":"2026-01-10T10:15:02.633149-05:00","labels":["complexity:low","model:haiku","phase-1","test"],"dependencies":[{"issue_id":"curb-008","depends_on_id":"curb-E01","type":"parent-child","created_at":"2026-01-10T10:17:10.652947-05:00","created_by":"lavallee"}]}
 {"id":"curb-009","title":"Write BATS tests for lib/artifacts.sh","description":"## Context\nTest coverage for artifact system ensures bundles are created correctly.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Use temp directories for test isolation. Verify file contents with jq.\n\n## Implementation Steps\n1. Create tests/artifacts.bats\n2. Test artifacts_init_run creates run.json\n3. Test artifacts_start_task creates task directory and task.json\n4. Test artifacts_capture_* functions create correct files\n5. Test artifacts_finalize_task updates JSON correctly\n6. Test artifacts_get_path returns correct paths\n7. Verify JSON validity with jq\n\n## Acceptance Criteria\n- [ ] tests/artifacts.bats exists\n- [ ] All artifacts functions have test coverage\n- [ ] Tests verify JSON structure with jq\n- [ ] Tests use isolated temp directories\n\n## Files Likely Involved\n- tests/artifacts.bats (new)\n- lib/artifacts.sh\n\n## Notes\nUse mktemp -d for test directories. Clean up in teardown.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-10T10:15:02.633149-05:00","updated_at":"2026-01-10T10:15:02.633149-05:00","labels":["complexity:medium","model:sonnet","phase-1","test"],"dependencies":[{"issue_id":"curb-009","depends_on_id":"curb-E01","type":"parent-child","created_at":"2026-01-10T10:17:10.689727-05:00","created_by":"lavallee"}]}
 {"id":"curb-010","title":"Integrate session and artifacts into main loop","description":"## Context\nIntegration connects the new modules to the existing main loop, enabling artifact generation during runs.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Add session_init at run start, artifacts calls around task execution.\n\n## Implementation Steps\n1. Source lib/session.sh and lib/artifacts.sh in curb\n2. Add --name flag parsing for session name override\n3. Call session_init at start of run (after config_load)\n4. Call artifacts_init_run after session_init\n5. Call artifacts_start_task before each task execution\n6. Call artifacts_capture_* during task execution\n7. Call artifacts_finalize_task after task completion\n8. Log session name and artifact paths\n\n## Acceptance Criteria\n- [ ] Session initialized at run start\n- [ ] --name flag works to override session name\n- [ ] Artifact bundle created for each task\n- [ ] Session name appears in logs\n- [ ] Artifacts contain expected files\n\n## Files Likely Involved\n- curb (main script)\n- lib/session.sh\n- lib/artifacts.sh\n\n## Notes\nCapture plan from harness output. Capture diff before and after task.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T10:15:02.633149-05:00","updated_at":"2026-01-10T12:03:40.63109-05:00","closed_at":"2026-01-10T12:03:40.63109-05:00","close_reason":"Integration complete. Session and artifacts modules successfully integrated into main loop.","labels":["complexity:medium","logic","model:sonnet","phase-1"],"dependencies":[{"issue_id":"curb-010","depends_on_id":"curb-E01","type":"parent-child","created_at":"2026-01-10T10:17:10.726287-05:00","created_by":"lavallee"}]}
-{"id":"curb-011","title":"CHECKPOINT: Verify artifact bundle generation end-to-end","description":"## Context\nValidation checkpoint to ensure Phase 1 deliverables work correctly before proceeding.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 20m\n**Approach:** Run curb on a test project and manually verify artifacts.\n\n## Implementation Steps\n1. Run full test suite: bats tests/\n2. Run curb on tests/e2e/project with a simple task\n3. Verify .curb/runs/\u003crun-id\u003e/ directory created\n4. Verify run.json contains correct metadata\n5. Verify tasks/\u003ctask-id\u003e/ contains all artifact files\n6. Verify task.json, plan.md, changes.patch, commands.jsonl, summary.md exist\n7. Document any issues found\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Artifact bundle directory structure is correct\n- [ ] All artifact files contain valid content\n- [ ] Session name appears in run.json\n- [ ] No regressions in existing functionality\n\n## Files Likely Involved\n- All Phase 1 files\n- tests/e2e/\n\n## Notes\nThis is a validation checkpoint. Fix any issues before proceeding to Phase 2.","status":"in_progress","priority":0,"issue_type":"task","created_at":"2026-01-10T10:15:02.633149-05:00","updated_at":"2026-01-10T12:05:13.413423-05:00","labels":["checkpoint","complexity:medium","model:sonnet","phase-1"],"dependencies":[{"issue_id":"curb-011","depends_on_id":"curb-E01","type":"parent-child","created_at":"2026-01-10T10:17:10.763099-05:00","created_by":"lavallee"}]}
+{"id":"curb-011","title":"CHECKPOINT: Verify artifact bundle generation end-to-end","description":"## Context\nValidation checkpoint to ensure Phase 1 deliverables work correctly before proceeding.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 20m\n**Approach:** Run curb on a test project and manually verify artifacts.\n\n## Implementation Steps\n1. Run full test suite: bats tests/\n2. Run curb on tests/e2e/project with a simple task\n3. Verify .curb/runs/\u003crun-id\u003e/ directory created\n4. Verify run.json contains correct metadata\n5. Verify tasks/\u003ctask-id\u003e/ contains all artifact files\n6. Verify task.json, plan.md, changes.patch, commands.jsonl, summary.md exist\n7. Document any issues found\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Artifact bundle directory structure is correct\n- [ ] All artifact files contain valid content\n- [ ] Session name appears in run.json\n- [ ] No regressions in existing functionality\n\n## Files Likely Involved\n- All Phase 1 files\n- tests/e2e/\n\n## Notes\nThis is a validation checkpoint. Fix any issues before proceeding to Phase 2.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T10:15:02.633149-05:00","updated_at":"2026-01-10T12:27:11.867207-05:00","closed_at":"2026-01-10T12:27:11.867207-05:00","close_reason":"Completed checkpoint validation. Fixed critical backend detection bug in lib/tasks.sh. All 394 tests pass. Documented 3 pre-existing test failures in curb.bats (--status, --ready flags). Backend detection now properly persists across function calls.","labels":["checkpoint","complexity:medium","model:sonnet","phase-1"],"dependencies":[{"issue_id":"curb-011","depends_on_id":"curb-E01","type":"parent-child","created_at":"2026-01-10T10:17:10.763099-05:00","created_by":"lavallee"}]}
 {"id":"curb-012","title":"Create subcommand dispatcher in curb entry point","description":"## Context\nThe dispatcher routes subcommands to handler functions, enabling the new CLI structure.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Use case statement at script start. Preserve backwards compatibility with flags.\n\n## Implementation Steps\n1. Define list of valid subcommands: init, run, status, explain, artifacts, version\n2. Add dispatcher function that checks if $1 matches a subcommand\n3. Route to cmd_* functions for each subcommand\n4. If no subcommand match, fall through to legacy flag parsing\n5. Pass remaining args to subcommand handlers\n6. Handle --help at dispatcher level\n\n## Acceptance Criteria\n- [ ] 'curb run' invokes cmd_run\n- [ ] 'curb init' invokes cmd_init\n- [ ] 'curb status' invokes cmd_status\n- [ ] Unknown subcommands show help\n- [ ] Legacy flags still work (backwards compatibility)\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nKeep dispatcher simple. Complex logic belongs in cmd_* functions.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-10T10:15:02.633149-05:00","updated_at":"2026-01-10T10:15:02.633149-05:00","labels":["complexity:medium","logic","model:sonnet","phase-2"],"dependencies":[{"issue_id":"curb-012","depends_on_id":"curb-E02","type":"parent-child","created_at":"2026-01-10T10:17:10.801514-05:00","created_by":"lavallee"}]}
 {"id":"curb-013","title":"Extract main loop logic into cmd_run function","description":"## Context\nMoving the main loop into cmd_run enables the subcommand interface while preserving all existing functionality.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Wrap existing main logic in cmd_run(). Parse run-specific flags inside.\n\n## Implementation Steps\n1. Create cmd_run() function\n2. Move existing main loop logic into cmd_run\n3. Parse run-specific flags: --once, --epic, --label, --harness, --model, --budget, --name, --push, --stream, --debug\n4. Keep flag parsing compatible with legacy invocation\n5. Ensure all existing functionality works via 'curb run'\n\n## Acceptance Criteria\n- [ ] 'curb run' executes the main loop\n- [ ] All existing flags work with 'curb run'\n- [ ] 'curb run --once' runs single iteration\n- [ ] 'curb run --epic X' filters by epic\n- [ ] No behavior changes from previous implementation\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nThis is a refactor, not a rewrite. Preserve exact behavior.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-10T10:15:02.633149-05:00","updated_at":"2026-01-10T10:15:02.633149-05:00","labels":["complexity:medium","logic","model:sonnet","phase-2"],"dependencies":[{"issue_id":"curb-013","depends_on_id":"curb-E02","type":"parent-child","created_at":"2026-01-10T10:17:10.837681-05:00","created_by":"lavallee"}]}
 {"id":"curb-014","title":"Move curb-init logic into cmd_init","description":"## Context\nConsolidating curb-init into curb init simplifies the CLI and reduces maintenance burden.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Copy curb-init logic into cmd_init, update paths, keep curb-init as thin wrapper.\n\n## Implementation Steps\n1. Create cmd_init() function in curb\n2. Copy initialization logic from curb-init\n3. Handle --global flag for global init\n4. Handle path argument for project init\n5. Update curb-init to be a thin wrapper that calls 'curb init'\n6. Add deprecation notice to curb-init\n\n## Acceptance Criteria\n- [ ] 'curb init' works for project initialization\n- [ ] 'curb init --global' works for global initialization\n- [ ] curb-init still works but shows deprecation notice\n- [ ] All init functionality preserved\n\n## Files Likely Involved\n- curb (main script)\n- curb-init\n\n## Notes\nKeep curb-init working for backwards compatibility but mark deprecated.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-10T10:15:02.633149-05:00","updated_at":"2026-01-10T10:15:02.633149-05:00","labels":["complexity:medium","logic","model:sonnet","phase-2"],"dependencies":[{"issue_id":"curb-014","depends_on_id":"curb-E02","type":"parent-child","created_at":"2026-01-10T10:17:10.873199-05:00","created_by":"lavallee"}]}
diff --git a/curb b/curb
index 85a8b66..66bac5e 100755
--- a/curb
+++ b/curb
@@ -147,9 +147,13 @@ check_deps() {
 validate_project() {
     log_debug "Validating project structure in ${PROJECT_DIR}"
 
-    # Detect task backend
+    # Detect and initialize task backend
+    # Note: tasks.sh is already sourced at top of script, defining _TASK_BACKEND global
+    # detect_backend echoes the result AND sets _TASK_BACKEND, but command substitution
+    # runs in subshell, so we explicitly set the global after getting the value
     local detected_backend
     detected_backend=$(detect_backend "${PROJECT_DIR}")
+    _TASK_BACKEND="$detected_backend"  # Explicitly set global to persist across function calls
     log_debug "Task backend: ${detected_backend}"
 
     if [[ "$detected_backend" == "beads" ]]; then
@@ -182,7 +186,7 @@ validate_project() {
 # Show task status summary
 show_status() {
     local prd="${PROJECT_DIR}/prd.json"
-    local backend=$(get_backend)
+    local backend=$(get_backend "${PROJECT_DIR}")
 
     # Validate JSON before processing (only for json backend)
     if [[ "$backend" == "json" ]]; then
@@ -224,7 +228,7 @@ show_status() {
 # Show ready tasks
 show_ready() {
     local prd="${PROJECT_DIR}/prd.json"
-    local backend=$(get_backend)
+    local backend=$(get_backend "${PROJECT_DIR}")
 
     # Validate JSON before processing (only for json backend)
     if [[ "$backend" == "json" ]]; then
@@ -296,12 +300,32 @@ run_iteration() {
     local prd="${PROJECT_DIR}/prd.json"
     log_debug "Starting iteration"
 
+    # Initialize session if not already initialized
+    if ! session_is_initialized; then
+        log_debug "Initializing session..."
+        if [[ -n "$SESSION_NAME" ]]; then
+            session_init --name "$SESSION_NAME"
+        else
+            session_init
+        fi
+
+        if [[ $? -ne 0 ]]; then
+            log_warn "Failed to initialize session"
+        else
+            local session_name
+            session_name=$(session_get_name)
+            local session_id
+            session_id=$(session_get_id)
+            log_debug "Session: ${session_name} (${session_id})"
+        fi
+    fi
+
     # Initialize logger if not already initialized
     if [[ -z "$(logger_get_file)" ]]; then
         local project_name
         project_name=$(basename "$PROJECT_DIR")
         local session_id
-        session_id=$(date +"%Y%m%d-%H%M%S")
+        session_id=$(session_get_id)
 
         if logger_init "$project_name" "$session_id"; then
             log_debug "Logger initialized: $(logger_get_file)"
@@ -310,6 +334,22 @@ run_iteration() {
         fi
     fi
 
+    # Initialize artifacts for this run if not already initialized
+    if session_is_initialized; then
+        local run_dir
+        run_dir=$(artifacts_get_run_dir 2>/dev/null)
+        if [[ -n "$run_dir" ]] && [[ ! -f "${run_dir}/run.json" ]]; then
+            log_debug "Initializing artifacts..."
+            if artifacts_init_run; then
+                local artifacts_path
+                artifacts_path=$(artifacts_get_run_dir)
+                log_debug "Artifacts initialized: ${artifacts_path}"
+            else
+                log_warn "Failed to initialize artifacts"
+            fi
+        fi
+    fi
+
     # Check for in-progress tasks first (resume interrupted work)
     # Respects --epic and --label filters
     local current_task
@@ -338,6 +378,7 @@ run_iteration() {
     if [[ -z "$current_task" || "$current_task" == "null" ]]; then
         # Find next ready task
         log_debug "No in-progress tasks, finding ready tasks..."
+        log_debug "Current _TASK_BACKEND: ${_TASK_BACKEND}"
         local ready_tasks
         ready_tasks=$(get_ready_tasks "$prd" "$EPIC" "$LABEL")
         log_debug "Ready tasks result: ${ready_tasks:0:200}..."
diff --git a/lib/tasks.sh b/lib/tasks.sh
index 3172d53..8a4951f 100755
--- a/lib/tasks.sh
+++ b/lib/tasks.sh
@@ -11,6 +11,12 @@
 #   - Auto-detect: uses beads if available and initialized, else json
 #
 
+# Include guard to prevent re-sourcing and resetting _TASK_BACKEND
+if [[ -n "${_TASKS_SH_LOADED:-}" ]]; then
+    return 0
+fi
+_TASKS_SH_LOADED=1
+
 CURB_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 
 # Source beads wrapper if available
@@ -67,9 +73,11 @@ detect_backend() {
 }
 
 # Get the current backend
+# Optional parameter: project_dir (defaults to current directory)
 get_backend() {
+    local project_dir="${1:-.}"
     if [[ -z "$_TASK_BACKEND" ]]; then
-        detect_backend >/dev/null
+        detect_backend "$project_dir" >/dev/null
     fi
     echo "$_TASK_BACKEND"
 }
@@ -116,7 +124,12 @@ get_ready_tasks() {
     local epic="${2:-}"   # Optional epic/parent filter
     local label="${3:-}"  # Optional label filter
 
-    if [[ "$(get_backend)" == "beads" ]]; then
+    local backend=$(get_backend)
+    if [[ "${DEBUG:-}" == "true" ]]; then
+        echo "[DEBUG get_ready_tasks] backend=$backend prd=$prd _TASK_BACKEND=$_TASK_BACKEND" >&2
+    fi
+
+    if [[ "$backend" == "beads" ]]; then
         beads_get_ready_tasks "$epic" "$label"
     else
         json_get_ready_tasks "$prd" "$epic" "$label"
@@ -262,7 +275,12 @@ json_get_ready_tasks() {
     local epic="${2:-}"
     local label="${3:-}"
 
-    jq --arg epic "$epic" --arg label "$label" '
+    if [[ "${DEBUG:-}" == "true" ]]; then
+        echo "[DEBUG json_get_ready_tasks] prd=$prd epic=$epic label=$label" >&2
+    fi
+
+    local result
+    result=$(jq --arg epic "$epic" --arg label "$label" '
         # Build a set of closed task IDs
         (.tasks | map(select(.status == "closed") | .id)) as $closed |
 
@@ -280,7 +298,13 @@ json_get_ready_tasks() {
         ]
         # Sort by priority (P0 < P1 < P2 < P3 < P4)
         | sort_by(.priority)
-    ' "$prd"
+    ' "$prd" 2>&1)
+
+    if [[ "${DEBUG:-}" == "true" ]]; then
+        echo "[DEBUG json_get_ready_tasks] result=${result:0:200}" >&2
+    fi
+
+    echo "$result"
 }
 
 # Get a specific task by ID from prd.json
