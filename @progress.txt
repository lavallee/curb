## Task: curb-018 - Update help text for subcommand CLI (Completed 2026-01-10)

### What was done
Implemented comprehensive help text for all subcommands and updated main help to clearly show the subcommand structure:
- Added cmd_init_help() with project/global initialization guidance
- Added cmd_run_help() with execution modes, filtering, and all available flags
- Added cmd_status_help() with output format examples
- Added cmd_artifacts_help() with task artifact access patterns and examples
- Added cmd_explain_help() with task detail retrieval guidance
- Updated main --help to show clear subcommand overview instead of huge flag listing
- All subcommands now support --help/-h flags for quick reference
- Included practical examples for common workflows in all help sections
- Ensured all help text fits within 80-column terminal (max line: 75 chars)

### Testing performed
- Manual testing of all subcommand help: `curb init --help`, `curb run --help`, etc.
- Main help tested: `curb --help` shows clear subcommand overview
- Line length verification: All output fits within 80 columns
- Full test suite: All 437 BATS tests pass with no regressions
- Verified help for error cases (unknown subcommands still show help)

### Key learnings
1. Help text organization is critical for discoverability - users should see subcommands first, not flags
2. Separate help functions for each subcommand makes the code cleaner and easier to maintain
3. Including examples in help text dramatically improves usability - users can copy/paste patterns
4. 80-column terminal width is still a real constraint - helps with readability on small terminals
5. The pattern of checking for --help at the start of each cmd_* function is clean and consistent
6. Help text should be organized into clear sections (USAGE, OPTIONS, EXAMPLES, SEE ALSO)
7. Cross-referencing between help sections (SEE ALSO) helps users discover related commands
8. Consistent formatting with aligned descriptions makes help text easier to scan

### Acceptance criteria met
✓ 'curb --help' shows subcommand overview
✓ 'curb run --help' shows run-specific options
✓ 'curb init --help' shows init-specific options
✓ Examples included for common use cases
✓ Help fits in standard terminal (80 cols, max achieved: 75)

### Files modified
- curb: Added help functions for init, run, status, artifacts, explain
- Updated main --help with subcommand-focused layout
- All functions now support --help/-h first-argument check

### Implementation stats
- Added 368 lines of help text
- Removed 91 lines of old verbose flag documentation
- Net addition: 277 lines (mostly help strings which improve UX significantly)
- Help functions follow consistent pattern: cmd_*_help() with heredoc
- Main help refactored from comprehensive flag listing to focused subcommand guide

## Task: curb-007 - Add curb version subcommand (Completed 2026-01-10)

### What was done
Implemented the version subcommand dispatcher pattern which establishes the foundation for adding more subcommands in Phase 2:
- Added cmd_version() function that prints 'curb v${CURB_VERSION}'
- Created subcommand dispatcher in main() that checks first argument before flag parsing
- Falls through to existing flag parsing for backward compatibility
- Version subcommand exits with code 0

### Testing performed
- Manual testing: `curb version` prints correct version string and exits with 0
- Backward compatibility: `--version` flag still works
- Other flags: `--help`, `--status` all continue working correctly
- Full test suite: All 394 BATS tests pass with no regressions

### Key learnings
1. The subcommand dispatcher pattern is clean: check subcommands first, then fall through to flag parsing
2. Bash case statements work well for dispatcher pattern - can easily extend for future subcommands
3. Important to maintain backward compatibility - both `curb version` and `curb --version` work
4. Minimal implementation (just 6 lines of code) establishes the pattern for Phase 2 refactoring
5. The pattern allows for future subcommands like cmd_run, cmd_init, cmd_status to be added symmetrically

### Files modified
- curb: Added cmd_version() function and subcommand dispatcher case statement
- .beads/issues.jsonl: Task status updated to closed

### Next tasks enabled
- curb-012: Create subcommand dispatcher in curb entry point (builds on this pattern)
- curb-013: Extract main loop logic into cmd_run function
- curb-014: Move curb-init logic into cmd_init

## Task: curb-a4p - Document config schema (Completed 2026-01-10)

### What was done
Created comprehensive configuration reference documentation in `docs/CONFIG.md` covering:
- Configuration precedence and priority order (CLI flags > env vars > project config > global config > defaults)
- All configuration sections: Harness, Budget, Loop, Clean State, Hooks
- Complete environment variables reference (15+ variables documented)
- CLI flags reference (16+ flags documented)
- Directory structure (XDG-compliant paths)
- Configuration examples for common scenarios (development, production, CI/CD, per-model)
- Debugging and troubleshooting sections

### Key learnings
1. Configuration hierarchy is well-designed with clear precedence rules
2. All config options have sensible defaults that work for most use cases
3. The configuration system supports both global (~/.config/curb/config.json) and project-level (.curb.json) overrides
4. Budget tracking is particularly important for cost control - warn_at threshold helps prevent surprise costs
5. Hooks system is flexible but requires clear documentation on locations and structure

### Files created/modified
- Created: docs/CONFIG.md (523 lines, comprehensive reference)
- Modified: README.md (added link to CONFIG.md in Configuration section)
- Task status: closed via beads (curb-a4p)

### Test results
All 327 existing BATS tests pass after changes.

### Dependencies
- Task blocks: curb-61a (Checkpoint: Curb 1.0 Ready for Release)
- No blocking dependencies

## Task: curb-61a - Checkpoint: Curb 1.0 Ready for Release (Completed 2026-01-10)

### What was done
Final release preparation and validation for Curb 1.0:
- Verified all 341+ BATS tests passing (327 from previous phases + new E2E tests)
- Created comprehensive CHANGELOG.md documenting all features across 4 development phases
- Added version constant (1.0.0) to curb and curb-init scripts
- Added --version flag to curb CLI for version reporting
- Updated --help output to list all 4 supported harnesses (Claude, Codex, Gemini, OpenCode)
- Created git tag v1.0.0 for release marking
- Verified all 8 markdown documentation files complete (~90 KB total)
- Committed release changes with complete changelog in commit message
- Closed task via beads

### Release Completeness
✓ All tests passing (341+ BATS tests)
✓ README reviewed and accurate (809 lines, 23.7 KB)
✓ CHANGELOG created with complete feature list
✓ Version bumped to 1.0.0
✓ Git tag v1.0.0 created
✓ Documentation complete and verified
✓ All 4 harnesses working (Claude, Codex, Gemini, OpenCode)
✓ 5 lifecycle hooks implemented
✓ Budget tracking functional
✓ Clean state verification working
✓ Test runner integration complete
✓ Structured JSONL logging working
✓ Dual task backends (beads + JSON)

### Documentation Summary
- README.md: Features, installation, usage, configuration, advanced topics
- CONFIG.md: Configuration reference with all options and examples
- UPGRADING.md: Migration guide for users upgrading from earlier versions
- CHANGELOG.md: Version history and feature list (newly created)
- AGENT.md: Build instructions for curb itself
- AGENTS.md: Supported AI coding agents description
- CONTRIBUTING.md: Contributor guidelines
- PROMPT.md: Default system prompt template

### Key Learnings
1. Curb 1.0 represents a complete, production-ready autonomous AI coding agent harness
2. The phased approach (Foundation → Reliability → Extensibility → Polish) successfully delivered all major features
3. Test coverage is comprehensive with 341+ tests covering all major code paths
4. Version management should include: constant in scripts, --version flag, git tag, and changelog
5. Documentation is critical for release - users need README, CONFIG, UPGRADING, and CONTRIBUTING guides
6. The combination of beads + JSON task backends provides flexibility for different user preferences
7. Multi-harness support (4 harnesses) with auto-detection provides good UX
8. Budget tracking with token counting is essential for controlling AI API costs
9. Structured logging in JSONL format enables debugging and analytics

### Files modified
- curb: Added CURB_VERSION constant, --version flag, updated --help with all harnesses
- curb-init: Added CURB_VERSION constant
- CHANGELOG.md: Created comprehensive changelog
- .beads/issues.jsonl: Task status updated to closed

### Test results
All 341+ BATS tests pass:
- config tests: 15 tests
- logger tests: 19 tests
- state tests: 20 tests
- budget tests: 12 tests
- harness tests: 38 tests
- hooks tests: 25 tests
- integration tests: 4 tests
- E2E tests: 6 tests
- XDG tests: 8 tests
- Tasks tests: 26 tests
Plus additional acceptance and edge case tests

### Release Status
Curb 1.0.0 is officially ready for production use. All phases complete:
- Phase 1 (Foundation): Config + Logging infrastructure
- Phase 2 (Reliability): Clean state + Budget enforcement
- Phase 3 (Extensibility): 4 harnesses + 5 hooks
- Phase 4 (Polish): Documentation + Help output + Migration tools

Next steps for future versions:
- Monitor real-world usage for edge cases
- Collect user feedback on harness and hook systems
- Consider additional integrations (GitHub, CI/CD platforms)
- Performance optimizations if needed
- Additional harness implementations as new AI tools emerge

## Task: curb-016 - Implement cmd_artifacts to show task artifact paths (Completed 2026-01-10)

### What was done
Implemented the cmd_artifacts function with full support for task artifact discovery and navigation:
- 'curb artifacts <task-id>' prints the full path to a task's artifact directory for easy access
- 'curb artifacts' with no arguments lists all recent tasks with their artifact paths
- Supports partial task ID prefix matching (e.g., 'curb artifacts curb-01' finds curb-012, curb-013, curb-014, etc.)
- Handles ambiguous matches gracefully by showing all matching tasks and asking for more specificity
- Provides helpful error messages when task not found, with a tip to run 'curb artifacts' to see available tasks

### Implementation approach
- Replaced previous subcommand-based design (list/show) with direct task lookup by task_id
- Uses find to recursively search .curb/runs/*/tasks/ for task directories
- Supports both exact matches and prefix matches on task IDs
- Returns single match paths directly (useful for scripts: `cd $(curb artifacts curb-016)`)
- Multiple matches show all options and ask user to be more specific

### Testing performed
- Manual tests with specific task IDs (curb-016) - works perfectly
- Tested prefix matching with partial IDs (curb-01) - correctly shows ambiguous matches
- Tested error case with non-existent task (curb-999) - provides helpful error message
- Full test suite: All 438 BATS tests pass with no regressions

### Key learnings
1. Task lookup across multiple run directories requires proper search strategy - find with maxdepth is efficient
2. Prefix matching is useful for user convenience but must handle ambiguity gracefully
3. Array handling in bash works well for collecting multiple matches and displaying them
4. Script-friendly output (single path on stdout) is important for command composition
5. Error messages should be actionable - telling users how to see available tasks is more helpful than just saying "not found"
6. Simple implementation is best - removed unnecessary list/show subcommands in favor of direct task_id lookup
7. The artifact directory structure (.curb/runs/{run-name}/tasks/{task-id}) maps naturally to task_id search

### Files modified
- curb: Replaced cmd_artifacts function with new task lookup implementation
- .beads/issues.jsonl: Task status updated to closed

### Acceptance criteria met
✓ 'curb artifacts <task-id>' prints path to artifacts
✓ 'curb artifacts' lists recent tasks with paths
✓ Helpful error message if task not found
✓ Works with partial task IDs (prefix match)
✓ All 438 BATS tests passing

### Next tasks enabled
- curb-017: Add deprecation warnings for legacy flag syntax (can now focus on CLI polish)
- Phase 2 tasks build on this stable artifact management foundation

## Task: curb-016 - Implement cmd_artifacts (Verification 2026-01-10)

### What was verified
Task curb-016 was already implemented in a previous iteration. Verification confirmed:
- cmd_artifacts function is fully functional and working as expected
- All acceptance criteria met through manual testing
- 'curb artifacts' lists recent task directories with paths
- 'curb artifacts curb-016' returns the correct artifact path
- 'curb artifacts curb-01' correctly shows ambiguous matches and asks for specificity
- 'curb artifacts curb-999' provides helpful error message with guidance

### Testing approach
- Manual testing of all subcommands and error cases
- Verified that the implementation handles edge cases gracefully
- Confirmed script-friendly output for command composition

### Key learnings
1. The cmd_artifacts implementation is clean and efficient - uses find with appropriate depth limits
2. The design decision to use direct task_id lookup instead of subcommands (list/show) is good
3. The implementation properly handles the .curb/runs directory structure across multiple runs
4. Error messages include helpful guidance (tip to run 'curb artifacts' to see available tasks)
5. The command returns single path on stdout for easy shell integration

### Task status
- Verified working and closed in beads
- No code changes needed
- Committed verification completion

## Task: curb-017 - Add deprecation warnings for legacy flag syntax (Completed 2026-01-10)

### What was done
Implemented deprecation warnings to help users migrate from legacy flags to new subcommand syntax:
- Added warn_deprecated_flag() helper function that outputs warnings to stderr
- Added warnings for --status, --ready, --plan and their short forms (-s, -r, -p, -1)
- Warnings include migration hints showing the new syntax (e.g., "use: curb status")
- Added CURB_NO_DEPRECATION_WARNINGS=1 environment variable to suppress warnings
- Fixed flag detection in subcommand dispatcher to properly handle single-dash flags

### Testing performed
- Manual testing: All legacy flags (--status, --ready, --plan, -s, -r, -p, -1) produce warnings
- Verified warning message format and includes new syntax hint
- Verified warnings go to stderr (not stdout)
- Verified suppression with CURB_NO_DEPRECATION_WARNINGS=1 env var
- Verified new syntax works without warnings (e.g., `curb status`)
- Full test suite: All 437 BATS tests pass with no regressions

### Key learnings
1. Deprecation warnings are important for backward compatibility during migration
2. Using stderr for warnings keeps stdout clean for scripting and command composition
3. Helper functions for warnings promote consistency across the codebase
4. Environment variables for feature control (like CURB_NO_DEPRECATION_WARNINGS) enable users to silence warnings in scripts
5. Flag detection needs to account for both single-dash (-) and double-dash (--) prefixes
6. Testing both long and short flag forms is important for completeness
7. Functional requirements (warnings go to stderr) need explicit testing to ensure they work correctly

### Files modified
- curb: Added warn_deprecated_flag() function, updated legacy flag handling, fixed flag detection regex
- .beads/issues.jsonl: Task status updated to closed

### Acceptance criteria met
✓ 'curb --status' warns and runs status
✓ Warning message includes new syntax hint
✓ Warning goes to stderr, not stdout
✓ CURB_NO_DEPRECATION_WARNINGS=1 suppresses warnings
✓ Functionality still works correctly
✓ All 437 BATS tests pass

### Code quality
- Minimal implementation: Added warn_deprecated_flag() function (8 lines)
- Updated legacy flag case statements (4 lines total changed)
- Fixed flag detection regex from `^--` to `^-` (1 line change)
- No breaking changes, full backward compatibility maintained

## Task: curb-008 - Write BATS tests for lib/session.sh (Completed 2026-01-10)

### What was done
Implemented comprehensive BATS test suite for the session management module covering all functions and edge cases:
- Created tests/session.bats with 34 test cases
- Tests for session_random_name(): validity, ANIMAL_NAMES membership, lowercase validation
- Tests for session_init(): no args (random animal), --name custom (specific name), timestamp format
- Tests for session_get_* functions: happy path, error before init, correct return formats
- Tests for session_is_initialized(): state checking with various scenarios
- Integration tests: full session lifecycle, custom naming, isolation between calls
- Error handling tests: consistency of error messages, edge cases with arguments
- Acceptance criteria tests: covering all specified requirements from task description

### Testing approach
- Used setup/teardown for test isolation - reset global session variables before and after each test
- Followed existing test patterns from logger.bats and xdg.bats
- Tested both happy paths and error cases
- Verified proper error messages and exit codes
- Used proper bash regex syntax (avoiding bash 4.4+ features like lowercase operator)
- Used grep -w for word boundary matching in animal names validation

### Key learnings
1. Test isolation is critical - session module uses global variables that must be reset between tests
2. Bash compatibility matters - avoided bash 4.4+ features like ${var,,} in favor of [[ ! "$var" =~ [A-Z] ]]
3. When using 'run' in BATS, global variables modified by the function are not accessible in the test - use function directly instead
4. ANIMAL_NAMES is space-separated, not array-indexed - need to use grep or case matching for lookup
5. The session ID format combining name and timestamp provides excellent debugging capability
6. ISO 8601 UTC timestamp format (YYYY-MM-DDTHH:MM:SSZ) is consistent across session module
7. Error messages are clear and help users understand what went wrong (must call init first)
8. Random animal selection creates memorable session identities while $RANDOM provides sufficient entropy for this use case

### Files created/modified
- Created: tests/session.bats (434 lines, comprehensive test suite)
- Modified: .beads/issues.jsonl (task status updated to closed)

### Test results
All 34 tests pass successfully:
- 3 tests for session_random_name function
- 7 tests for session_init function
- 3 tests for session_get_name function
- 3 tests for session_get_id function
- 2 tests for session_get_run_id function
- 4 tests for session_is_initialized function
- 3 tests for integration scenarios
- 1 test for error handling consistency
- 1 test for multiple --name handling
- 7 tests covering acceptance criteria

### Acceptance criteria met
✓ tests/session.bats exists with proper structure
✓ All session functions have comprehensive test coverage (session_random_name, session_init, session_get_*, session_is_initialized)
✓ Tests pass: `bats tests/session.bats` - all 34 tests pass
✓ Error cases are tested (getters before init, invalid options, edge cases)
✓ Happy path and error scenarios both validated
✓ Test isolation using setup/teardown functions
✓ Integration tests verify full lifecycle

### Dependencies
- Depends on: curb-001 (lib/session.sh created), curb-002 (session functions implemented)
- Enables: curb-009 (BATS tests for lib/artifacts.sh), curb-010 (integration into main loop)

### Notes for future tests
- Remember to reset global variables in setup() when testing modules with state
- Use function calls directly (not 'run') when tests need to verify global variable changes
- Be careful with bash version compatibility - test on target bash version (3.2+)
