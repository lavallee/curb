#!/usr/bin/env bash
#
# curb - Claude Under Ralph + Beads
#
# Autonomous AI coding agent harness that drives Claude Code in a loop
# to build software from a prd.json backlog with beads-style task tracking.
#
# Usage:
#   curb              # Run loop until all tasks complete
#   curb --once       # Run single iteration
#   curb --status     # Show current task status
#   curb --ready      # Show ready tasks
#   curb --plan       # Run in planning mode (generate fix_plan.md)
#   curb --budget 1000000  # Set token budget for run
#   curb --debug      # Enable debug logging (can combine with other flags)
#
set -euo pipefail

CURB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="${CURB_PROJECT_DIR:-$(pwd)}"

# Source task management library
source "${CURB_DIR}/lib/tasks.sh"
# Source harness abstraction layer
source "${CURB_DIR}/lib/harness.sh"
# Source XDG directory helpers
source "${CURB_DIR}/lib/xdg.sh"
# Source configuration management
source "${CURB_DIR}/lib/config.sh"
# Source logger
source "${CURB_DIR}/lib/logger.sh"
# Source state verification
source "${CURB_DIR}/lib/state.sh"
# Source budget tracking
source "${CURB_DIR}/lib/budget.sh"

# Load configuration early
config_load

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Debug mode (set via --debug flag)
DEBUG="${CURB_DEBUG:-false}"
# Stream mode (set via --stream flag)
STREAM="${CURB_STREAM:-false}"
# Backend mode (set via --backend flag or CURB_BACKEND env)
# Values: "auto", "beads", "json"
BACKEND="${CURB_BACKEND:-auto}"
# Harness (set via --harness flag, HARNESS env, or config file)
# Values: "auto", "claude", "codex"
# Priority: CLI flag > env var > config file > default
HARNESS="${HARNESS:-$(config_get_or "harness.default" "auto")}"
# Model (set via --model flag or CURB_MODEL env)
# Values: "opus", "sonnet", "haiku" (only applies to claude harness)
MODEL="${CURB_MODEL:-}"
# Epic filter (set via --epic flag or CURB_EPIC env)
EPIC="${CURB_EPIC:-}"
# Label filter (set via --label flag or CURB_LABEL env)
LABEL="${CURB_LABEL:-}"
# Budget (set via --budget flag, CURB_BUDGET env, or config file)
BUDGET="${CURB_BUDGET:-}"
# Require clean state (set via --require-clean flag or config)
# Empty means use config default, "true"/"false" overrides config
REQUIRE_CLEAN="${CURB_REQUIRE_CLEAN:-}"

log_info() { echo -e "${BLUE}[curb]${NC} $1"; }
log_success() { echo -e "${GREEN}[curb]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[curb]${NC} $1"; }
_log_error_console() { echo -e "${RED}[curb]${NC} $1" >&2; }
log_debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${DIM}${CYAN}[debug]${NC}${DIM} $1${NC}" >&2
    fi
}

# Check dependencies
check_deps() {
    local missing=()
    command -v jq >/dev/null 2>&1 || missing+=("jq")

    # Check for at least one harness
    if ! harness_available; then
        missing+=("harness (claude or codex)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        _log_error_console "Missing dependencies: ${missing[*]}"
        exit 1
    fi

    # Log which harness is active
    log_debug "Harness: $(harness_get)"
}

# Validate project structure
validate_project() {
    log_debug "Validating project structure in ${PROJECT_DIR}"

    # Detect task backend
    local detected_backend
    detected_backend=$(detect_backend "${PROJECT_DIR}")
    log_debug "Task backend: ${detected_backend}"

    if [[ "$detected_backend" == "beads" ]]; then
        log_info "Using beads backend"
        # Beads doesn't need prd.json
    else
        log_info "Using JSON backend (prd.json)"
        if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
            _log_error_console "No prd.json found in ${PROJECT_DIR}"
            log_info "Run 'curb-init' to scaffold a new project"
            exit 1
        fi
        log_debug "Found prd.json ($(wc -c < "${PROJECT_DIR}/prd.json") bytes)"
    fi

    if [[ ! -f "${PROJECT_DIR}/PROMPT.md" ]]; then
        log_warn "No PROMPT.md found, using default template"
        cp "${CURB_DIR}/templates/PROMPT.md" "${PROJECT_DIR}/PROMPT.md"
    fi
    log_debug "Found PROMPT.md ($(wc -l < "${PROJECT_DIR}/PROMPT.md") lines)"

    if [[ ! -f "${PROJECT_DIR}/AGENT.md" ]]; then
        log_warn "No AGENT.md found, using default template"
        cp "${CURB_DIR}/templates/AGENT.md" "${PROJECT_DIR}/AGENT.md"
    fi
    log_debug "Found AGENT.md ($(wc -l < "${PROJECT_DIR}/AGENT.md") lines)"
    log_debug "Project validation complete"
}

# Show task status summary
show_status() {
    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend)

    # Validate JSON before processing (only for json backend)
    if [[ "$backend" == "json" ]]; then
        if ! jq empty "$prd" 2>/dev/null; then
            _log_error_console "Invalid JSON in prd.json"
            return 1
        fi
    fi

    echo ""
    log_info "Task Status Summary"
    echo "===================="

    local counts
    counts=$(get_task_counts "$prd")
    local total=$(echo "$counts" | jq -r '.total')
    local closed=$(echo "$counts" | jq -r '.closed')
    local in_progress=$(echo "$counts" | jq -r '.in_progress')
    local open=$(echo "$counts" | jq -r '.open')

    echo -e "Total:       ${total}"
    echo -e "Closed:      ${GREEN}${closed}${NC}"
    echo -e "In Progress: ${YELLOW}${in_progress}${NC}"
    echo -e "Open:        ${open}"
    echo ""

    # Progress bar
    if [[ "$total" -gt 0 ]]; then
        local pct=$((closed * 100 / total))
        local filled=$((pct / 5))
        local empty=$((20 - filled))
        printf "Progress: ["
        printf "%0.s#" $(seq 1 $filled 2>/dev/null) || true
        printf "%0.s-" $(seq 1 $empty 2>/dev/null) || true
        printf "] %d%%\n" "$pct"
    fi
}

# Show ready tasks
show_ready() {
    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend)

    # Validate JSON before processing (only for json backend)
    if [[ "$backend" == "json" ]]; then
        if ! jq empty "$prd" 2>/dev/null; then
            _log_error_console "Invalid JSON in prd.json"
            return 1
        fi
    fi

    log_info "Ready Tasks (unblocked, status=open)"
    if [[ -n "$EPIC" ]]; then
        log_info "  Epic filter: $EPIC"
    fi
    if [[ -n "$LABEL" ]]; then
        log_info "  Label filter: $LABEL"
    fi
    echo "======================================"

    local ready=$(get_ready_tasks "$prd" "$EPIC" "$LABEL")

    if [[ -z "$ready" || "$ready" == "null" || "$ready" == "[]" ]]; then
        log_warn "No ready tasks found"
        return
    fi

    echo "$ready" | jq -r '.[] | "[\(.priority)] \(.id): \(.title)"'
}

# Generate the system prompt (static instructions from PROMPT.md)
generate_system_prompt() {
    cat "${PROJECT_DIR}/PROMPT.md"
}

# Generate the task prompt (just the current task details - kept short for stdin)
generate_task_prompt() {
    local task_json="$1"

    # Extract task details
    local task_id=$(echo "$task_json" | jq -r '.id')
    local task_title=$(echo "$task_json" | jq -r '.title')
    local task_type=$(echo "$task_json" | jq -r '.type')
    local task_desc=$(echo "$task_json" | jq -r '.description')
    local task_criteria=$(echo "$task_json" | jq -r '.acceptanceCriteria // [] | join("\n- ")')

    # Generate focused task prompt (minimal - just the task)
    cat <<EOF
## CURRENT TASK

Task ID: ${task_id}
Type: ${task_type}
Title: ${task_title}

Description:
${task_desc}

Acceptance Criteria:
- ${task_criteria}

When complete:
1. Run feedback loops (typecheck, test, lint)
2. Update prd.json: set status to "closed" for ${task_id}
3. Commit: ${task_type}(${task_id}): ${task_title}
4. Append learnings to progress.txt
EOF
}

# Run a single iteration
run_iteration() {
    local prd="${PROJECT_DIR}/prd.json"
    log_debug "Starting iteration"

    # Initialize logger if not already initialized
    if [[ -z "$(logger_get_file)" ]]; then
        local project_name
        project_name=$(basename "$PROJECT_DIR")
        local session_id
        session_id=$(date +"%Y%m%d-%H%M%S")

        if logger_init "$project_name" "$session_id"; then
            log_debug "Logger initialized: $(logger_get_file)"
        else
            log_warn "Failed to initialize logger"
        fi
    fi

    # Check for in-progress tasks first (resume interrupted work)
    # Respects --epic and --label filters
    local current_task
    log_debug "Checking for in-progress tasks..."
    current_task=$(get_in_progress_task "$prd" "$EPIC" "$LABEL")
    log_debug "In-progress query result: ${current_task:0:100}..."

    if [[ -n "$current_task" && "$current_task" != "null" ]]; then
        local task_id=$(echo "$current_task" | jq -r '.id')
        local task_title=$(echo "$current_task" | jq -r '.title')
        local task_type=$(echo "$current_task" | jq -r '.type')

        # Verify the in-progress task is not blocked
        if is_task_ready "$prd" "$task_id"; then
            log_warn "Resuming in-progress task: ${task_id}"
            log_info "  ${task_type}: ${task_title}"
            log_debug "Task JSON: $current_task"
        else
            log_warn "In-progress task ${task_id} is blocked, resetting to open"
            update_task_status "$prd" "$task_id" "open"
            current_task=""
        fi
    fi

    # Find next ready task if no valid in-progress task
    if [[ -z "$current_task" || "$current_task" == "null" ]]; then
        # Find next ready task
        log_debug "No in-progress tasks, finding ready tasks..."
        local ready_tasks
        ready_tasks=$(get_ready_tasks "$prd" "$EPIC" "$LABEL")
        log_debug "Ready tasks result: ${ready_tasks:0:200}..."

        if [[ -z "$ready_tasks" || "$ready_tasks" == "[]" ]]; then
            # Check if we're done
            local open_count=$(get_remaining_count "$prd")
            log_debug "Open task count: ${open_count}"
            if [[ "$open_count" -eq 0 ]]; then
                log_success "All tasks complete!"
                return 0
            else
                _log_error_console "No ready tasks but ${open_count} tasks not closed. Check dependencies."
                return 1
            fi
        fi

        # Pick highest priority ready task
        current_task=$(echo "$ready_tasks" | jq 'first')
        local task_id=$(echo "$current_task" | jq -r '.id')
        local task_title=$(echo "$current_task" | jq -r '.title')
        local task_type=$(echo "$current_task" | jq -r '.type')
        local task_priority=$(echo "$current_task" | jq -r '.priority')

        log_info "Selected task: ${task_id} [${task_priority}]"
        log_info "  ${task_type}: ${task_title}"
        log_debug "Task JSON: $current_task"

        # Mark as in_progress
        log_debug "Updating task status to in_progress..."
        update_task_status "$prd" "$task_id" "in_progress"
        log_debug "Task status updated"
    fi

    # Check for model: label and set CURB_MODEL if harness is claude
    local harness=$(harness_get)
    if [[ "$harness" == "claude" ]]; then
        local task_model
        task_model=$(echo "$current_task" | jq -r '.labels // [] | .[] | select(startswith("model:")) | split(":")[1]' 2>/dev/null | head -1)
        if [[ -n "$task_model" ]]; then
            log_info "  Model from label: ${task_model}"
            export CURB_MODEL="$task_model"
        fi
    fi

    # Generate prompts
    log_debug "Generating prompts..."
    local system_prompt
    system_prompt=$(generate_system_prompt)
    local task_prompt
    task_prompt=$(generate_task_prompt "$current_task")

    local sys_bytes=$(echo "$system_prompt" | wc -c)
    local task_bytes=$(echo "$task_prompt" | wc -c)
    log_debug "System prompt: ${sys_bytes} bytes (via --append-system-prompt)"
    log_debug "Task prompt: ${task_bytes} bytes (via stdin)"

    # Show prompts in debug mode
    if [[ "$DEBUG" == "true" ]]; then
        echo ""
        log_debug "=== SYSTEM PROMPT ==="
        echo -e "${DIM}$system_prompt${NC}" >&2
        log_debug "=== TASK PROMPT ==="
        echo -e "${DIM}$task_prompt${NC}" >&2
        log_debug "===================="
        echo ""
    fi

    log_info "Running ${harness}..."
    echo ""

    if [[ "$DEBUG" == "true" ]]; then
        # Pre-flight check
        log_debug "Pre-flight: ${harness} version"
        local version_output
        version_output=$(harness_version 2>&1) && log_debug "Version: ${version_output}" || log_debug "WARNING: version check failed"
        log_debug "Binary: $(which ${harness})"
    fi

    # Extract task details for logging
    local task_id=$(echo "$current_task" | jq -r '.id')
    local task_title=$(echo "$current_task" | jq -r '.title')

    # Log task start
    log_task_start "$task_id" "$task_title" "$harness"

    # Run harness with the prompt via abstraction layer
    local start_time=$(date +%s)
    local exit_code=0
    log_debug "Execution start: $(date)"

    if [[ "$DEBUG" == "true" ]]; then
        # Save prompts to temp files for manual testing
        local tmp_sys=$(mktemp)
        local tmp_task=$(mktemp)
        echo "$system_prompt" > "$tmp_sys"
        echo "$task_prompt" > "$tmp_task"
        log_debug "System prompt: ${tmp_sys}"
        log_debug "Task prompt: ${tmp_task}"
        log_debug ">>> Prompts saved for debugging"
        log_debug ""
        log_debug "--- HARNESS START (${harness}) ---"
    fi

    # Invoke harness via abstraction layer
    if [[ "$STREAM" == "true" ]]; then
        log_info "Streaming ${harness} output..."
        harness_invoke_streaming "$system_prompt" "$task_prompt" "$DEBUG"
        exit_code=$?
    else
        harness_invoke "$system_prompt" "$task_prompt" "$DEBUG"
        exit_code=$?
    fi

    if [[ "$DEBUG" == "true" ]]; then
        log_debug "--- HARNESS END (${harness}) ---"

        # Cleanup on success, keep on failure
        if [[ $exit_code -eq 0 ]]; then
            rm -f "$tmp_sys" "$tmp_task"
        else
            log_debug "Keeping prompt files for debugging"
            log_debug "  System: ${tmp_sys}"
            log_debug "  Task: ${tmp_task}"
        fi
    fi

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    log_debug "Execution end: $(date)"
    log_debug "Duration: ${duration} seconds"
    log_debug "Exit code: ${exit_code}"

    # Extract token usage from harness
    local tokens_used=0
    tokens_used=$(harness_get_total_tokens)
    log_debug "Tokens used: ${tokens_used}"

    # Record token usage in budget if budget is initialized
    local budget_remaining=""
    local budget_total=""
    if [[ -f "${TMPDIR:-/tmp}/curb_budget_limit_$$" ]]; then
        log_debug "Recording ${tokens_used} tokens to budget"
        budget_record "$tokens_used"
        budget_remaining=$(budget_remaining)
        budget_total=$(budget_get_limit)
        log_debug "Budget: ${budget_remaining} remaining of ${budget_total}"

        # Check if warning threshold has been crossed
        local warn_at
        warn_at=$(config_get_or "budget.warn_at" "80")
        if budget_check_warning "$warn_at"; then
            : # No warning triggered
        else
            # Warning was just triggered - log it once
            if [[ "$budget_total" -gt 0 ]]; then
                local used=$(budget_get_used)
                local percentage=$((used * 100 / budget_total))
                log_warn "Budget warning: approaching limit (${percentage}% used, ${budget_remaining} tokens remaining)"
            fi
        fi
    fi

    # Log task end with budget information
    if [[ -n "$budget_remaining" && -n "$budget_total" ]]; then
        log_task_end "$task_id" "$exit_code" "$duration" "$tokens_used" "$budget_remaining" "$budget_total"
    else
        log_task_end "$task_id" "$exit_code" "$duration" "$tokens_used"
    fi

    if [[ $exit_code -ne 0 ]]; then
        log_warn "Claude Code exited with code ${exit_code}"
        log_debug "Non-zero exit may indicate: timeout, error, or user interrupt"
        # Log error to structured logger
        log_error "Harness exited with non-zero code" "{\"task_id\": \"$task_id\", \"exit_code\": $exit_code, \"harness\": \"$harness\"}"
    else
        log_debug "Claude Code completed successfully"

        # Verify clean state after successful harness run
        log_debug "Checking repository state..."
        if ! state_ensure_clean "$REQUIRE_CLEAN"; then
            log_warn "State check failed: uncommitted changes detected"
            exit_code=1
        else
            log_debug "Repository state is clean"
        fi

        # Run tests if configured
        if [[ $exit_code -eq 0 ]]; then
            log_debug "Running tests if configured..."
            if ! state_run_tests; then
                log_warn "Test run failed"
                exit_code=1
            else
                log_debug "Tests passed or not required"
            fi
        fi
    fi

    return $exit_code
}

# Run planning mode
run_planning() {
    local prd="${PROJECT_DIR}/prd.json"
    log_debug "Starting planning mode"

    log_info "Running in planning mode..."

    local plan_prompt
    plan_prompt=$(cat <<'EOF'
Study @specs/* for specifications.
Study @prd.json for the current task backlog.
Study the existing source code.

Your task is to analyze the codebase and update @fix_plan.md:

1. Use subagents to study existing source code and compare against specifications
2. Search for TODO comments, placeholder implementations, and missing functionality
3. Create/update fix_plan.md with a prioritized bullet list of items to implement
4. For each item, note:
   - What needs to be done
   - Which files are affected
   - Dependencies on other items
5. If you discover missing specifications, document them

Think hard. Be thorough. Use many parallel subagents for research.
EOF
)

    if [[ "$DEBUG" == "true" ]]; then
        log_debug "Plan prompt: $(echo "$plan_prompt" | wc -l) lines"
        log_debug "=== PLAN PROMPT ==="
        echo -e "${DIM}$plan_prompt${NC}" >&2
        log_debug "==================="
    fi

    local start_time=$(date +%s)
    log_debug "Execution start: $(date)"

    echo "$plan_prompt" | claude -p --dangerously-skip-permissions

    local exit_code=$?
    local end_time=$(date +%s)
    log_debug "Execution end: $(date), duration: $((end_time - start_time))s, exit: ${exit_code}"
}

# Main loop
run_loop() {
    local max_iterations="${CURB_MAX_ITERATIONS:-$(config_get_or "loop.max_iterations" "100")}"
    local iteration=0

    # Initialize logger with project name and session ID
    local project_name
    project_name=$(basename "$PROJECT_DIR")
    local session_id
    session_id=$(date +"%Y%m%d-%H%M%S")

    if logger_init "$project_name" "$session_id"; then
        log_debug "Logger initialized: $(logger_get_file)"
    else
        log_warn "Failed to initialize logger"
    fi

    log_info "Starting curb loop (max ${max_iterations} iterations)"
    log_debug "Max iterations: ${max_iterations}"
    log_debug "Loop starting at: $(date)"
    echo ""

    while [[ $iteration -lt $max_iterations ]]; do
        iteration=$((iteration + 1))
        log_info "=== Iteration ${iteration} ==="
        log_debug "--- Iteration ${iteration} start: $(date) ---"

        # Check if all tasks complete
        local prd="${PROJECT_DIR}/prd.json"
        log_debug "Querying remaining tasks..."
        local remaining=$(get_remaining_count "$prd")
        log_debug "Remaining tasks: ${remaining}"

        if [[ "$remaining" -eq 0 ]]; then
            log_success "All tasks complete! Exiting loop."
            show_status
            return 0
        fi

        # Run single iteration
        log_debug "Calling run_iteration..."
        if ! run_iteration; then
            log_warn "Iteration failed, continuing..."
            log_debug "run_iteration returned non-zero"
        fi

        echo ""
        log_info "Iteration ${iteration} complete. ${remaining} tasks remaining."
        log_debug "--- Iteration ${iteration} end: $(date) ---"
        echo ""

        # Check budget after iteration if budget is initialized
        if [[ -f "${TMPDIR:-/tmp}/curb_budget_limit_$$" ]]; then
            if ! budget_check; then
                local used=$(budget_get_used)
                local limit=$(budget_get_limit)
                echo ""
                log_success "Budget exceeded (used ${used} of ${limit} tokens)"
                log_info "Stopping gracefully due to budget limit"
                show_status
                return 0
            fi
        fi

        # Brief pause between iterations to allow for interruption
        log_debug "Sleeping 2 seconds before next iteration..."
        sleep 2
    done

    log_warn "Reached max iterations (${max_iterations})"
    log_debug "Loop terminated at: $(date)"
    show_status
    return 1
}

# Main entry point
main() {
    # Parse flags first (can be combined with other flags)
    local args=()
    for arg in "$@"; do
        if [[ "$arg" == "--debug" || "$arg" == "-d" ]]; then
            DEBUG="true"
            log_debug "Debug mode enabled"
            log_debug "CURB_DIR=${CURB_DIR}"
            log_debug "PROJECT_DIR=${PROJECT_DIR}"
            log_debug "Shell: $SHELL (bash ${BASH_VERSION})"
            log_debug "Date: $(date)"
        elif [[ "$arg" == "--stream" ]]; then
            STREAM="true"
            log_info "Stream mode enabled - showing harness activity"
        elif [[ "$arg" == "--require-clean" ]]; then
            REQUIRE_CLEAN="true"
            export CURB_REQUIRE_CLEAN="true"
            log_info "Clean state enforcement enabled via CLI flag"
        elif [[ "$arg" == "--no-require-clean" ]]; then
            REQUIRE_CLEAN="false"
            export CURB_REQUIRE_CLEAN="false"
            log_info "Clean state enforcement disabled via CLI flag"
        elif [[ "$arg" == "--backend="* ]]; then
            BACKEND="${arg#--backend=}"
            export CURB_BACKEND="$BACKEND"
        elif [[ "$arg" == "--backend" ]]; then
            # Next arg is the backend value - handle in next iteration
            _next_is_backend=true
            continue
        elif [[ "${_next_is_backend:-}" == "true" ]]; then
            BACKEND="$arg"
            export CURB_BACKEND="$BACKEND"
            _next_is_backend=false
        elif [[ "$arg" == "--harness="* ]]; then
            HARNESS="${arg#--harness=}"
            export HARNESS
        elif [[ "$arg" == "--harness" ]]; then
            # Next arg is the harness value - handle in next iteration
            _next_is_harness=true
            continue
        elif [[ "${_next_is_harness:-}" == "true" ]]; then
            HARNESS="$arg"
            export HARNESS
            _next_is_harness=false
        elif [[ "$arg" == "--model="* ]]; then
            MODEL="${arg#--model=}"
            export CURB_MODEL="$MODEL"
        elif [[ "$arg" == "--model" ]]; then
            # Next arg is the model value - handle in next iteration
            _next_is_model=true
            continue
        elif [[ "${_next_is_model:-}" == "true" ]]; then
            MODEL="$arg"
            export CURB_MODEL="$MODEL"
            _next_is_model=false
        elif [[ "$arg" == "--epic="* ]]; then
            EPIC="${arg#--epic=}"
            export CURB_EPIC="$EPIC"
        elif [[ "$arg" == "--epic" ]]; then
            _next_is_epic=true
            continue
        elif [[ "${_next_is_epic:-}" == "true" ]]; then
            EPIC="$arg"
            export CURB_EPIC="$EPIC"
            _next_is_epic=false
        elif [[ "$arg" == "--label="* ]]; then
            LABEL="${arg#--label=}"
            export CURB_LABEL="$LABEL"
        elif [[ "$arg" == "--label" ]]; then
            _next_is_label=true
            continue
        elif [[ "${_next_is_label:-}" == "true" ]]; then
            LABEL="$arg"
            export CURB_LABEL="$LABEL"
            _next_is_label=false
        elif [[ "$arg" == "--budget="* ]]; then
            BUDGET="${arg#--budget=}"
            export CURB_BUDGET="$BUDGET"
        elif [[ "$arg" == "--budget" ]]; then
            # Next arg is the budget value - handle in next iteration
            _next_is_budget=true
            continue
        elif [[ "${_next_is_budget:-}" == "true" ]]; then
            BUDGET="$arg"
            export CURB_BUDGET="$BUDGET"
            _next_is_budget=false
        else
            args+=("$arg")
        fi
    done
    unset _next_is_backend
    unset _next_is_harness
    unset _next_is_model
    unset _next_is_epic
    unset _next_is_label
    unset _next_is_budget

    check_deps
    log_debug "Dependencies checked: jq and harness found"

    # Initialize budget if provided via CLI or environment
    # Get budget from: CLI flag > environment > config file
    local budget_limit="${BUDGET:-$(config_get_or "budget.limit" "")}"
    if [[ -n "$budget_limit" ]]; then
        if budget_init "$budget_limit"; then
            log_info "Budget initialized: ${budget_limit} tokens"
        else
            log_warn "Failed to initialize budget with value: ${budget_limit}"
        fi
    fi

    case "${args[0]:-}" in
        --status|-s)
            validate_project
            show_status
            ;;
        --ready|-r)
            validate_project
            show_ready
            ;;
        --once|-1)
            validate_project
            run_iteration
            ;;
        --plan|-p)
            validate_project
            run_planning
            ;;
        --test|-t)
            log_info "Testing Claude Code invocation..."
            log_debug "Binary: $(which claude)"
            log_debug "Version: $(claude --version 2>&1)"
            echo ""
            log_info "Test 1: Simple echo pipe"
            log_debug "Command: echo 'Say hello' | claude -p"
            if echo "Say hello" | claude -p; then
                log_success "Test 1 passed"
            else
                _log_error_console "Test 1 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 2: Heredoc pipe"
            log_debug "Command: claude -p <<< 'Say goodbye'"
            if claude -p <<< "Say goodbye"; then
                log_success "Test 2 passed"
            else
                _log_error_console "Test 2 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 3: Multi-line prompt"
            local test_prompt="You are a helpful assistant.

Say 'curb test successful' and nothing else."
            log_debug "Command: echo \"\$test_prompt\" | claude -p"
            if echo "$test_prompt" | claude -p; then
                log_success "Test 3 passed"
            else
                _log_error_console "Test 3 failed (exit: $?)"
            fi
            echo ""
            log_success "All tests complete"
            ;;
        --migrate-to-beads)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                _log_error_console "No prd.json found to migrate"
                exit 1
            fi
            log_info "Migrating from prd.json to beads..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "false"
            ;;
        --migrate-to-beads-dry-run)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                _log_error_console "No prd.json found to migrate"
                exit 1
            fi
            log_info "DRY RUN: Showing what would be migrated..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "true"
            ;;
        --dump-prompt)
            validate_project
            local prd="${PROJECT_DIR}/prd.json"
            local current_task
            current_task=$(get_in_progress_task "$prd")
            if [[ -z "$current_task" || "$current_task" == "null" ]]; then
                current_task=$(get_ready_tasks "$prd" | jq 'first')
            fi
            if [[ "$current_task" == "null" || -z "$current_task" ]]; then
                _log_error_console "No tasks available"
                exit 1
            fi
            local sys_file="${PROJECT_DIR}/curb_system_prompt.txt"
            local task_file="${PROJECT_DIR}/curb_task_prompt.txt"
            generate_system_prompt > "$sys_file"
            generate_task_prompt "$current_task" > "$task_file"
            log_success "Prompts dumped:"
            log_info "  System: ${sys_file} ($(wc -c < "$sys_file") bytes)"
            log_info "  Task:   ${task_file} ($(wc -c < "$task_file") bytes)"
            log_info ""
            log_info "To test manually:"
            log_info "  claude -p --append-system-prompt \"\$(cat ${sys_file})\" < ${task_file}"
            ;;
        --help|-h)
            cat <<EOF
curb - Claude Under Ralph + Beads

Autonomous AI coding agent that drives coding harnesses (Claude Code or OpenAI
Codex) in a loop.

Usage:
  curb              Run loop until all tasks complete
  curb --once       Run single iteration
  curb --status     Show current task status
  curb --ready      Show ready tasks
  curb --plan       Run in planning mode
  curb --test       Test harness invocation with simple prompts
  curb --dump-prompt  Dump the actual prompt to a file for inspection
  curb --migrate-to-beads      Migrate tasks from prd.json to beads
  curb --migrate-to-beads-dry-run  Preview migration without making changes
  curb --debug      Enable debug logging (can combine with other flags)
  curb --stream     Stream harness activity in real-time (can combine)
  curb --backend X  Force task backend: "beads" or "json" (default: auto-detect)
  curb --harness X  Force harness: "claude" or "codex" (default: auto-detect)
  curb --model X    Set Claude model: "opus", "sonnet", or "haiku"
  curb --budget X   Set token budget for this run
  curb --epic <id>  Filter to tasks within a specific epic
  curb --label <name> Filter to tasks with a specific label

Flags:
  --debug, -d       Enable verbose debug output including:
                    - Full prompt being sent to harness
                    - Task selection details and JSON
                    - Timing information
                    - Saves prompt to temp file for debugging
  --stream          Stream harness activity showing:
                    - Tool calls as they happen
                    - Text responses in real-time
                    - Final result and cost
  --backend <mode>  Task backend selection:
                    - auto: use beads if available, else json (default)
                    - beads: use beads CLI (bd) for task management
                    - json: use prd.json file directly
  --harness <name>  Harness selection:
                    - auto: prefer claude, fall back to codex (default)
                    - claude: use Claude Code CLI
                    - codex: use OpenAI Codex CLI
  --model <name>    Claude model selection (only applies to claude harness):
                    - opus: Claude Opus (most capable)
                    - sonnet: Claude Sonnet (balanced)
                    - haiku: Claude Haiku (fastest)
  --epic <id>       Filter to tasks that are children of the specified epic
  --label <name>    Filter to tasks with the specified label (e.g., "phase-1")
  --budget <tokens> Set token budget limit (default from config or env)
  --require-clean   Force clean state enforcement (overrides config)
  --no-require-clean  Disable clean state enforcement (overrides config)

Environment:
  CURB_PROJECT_DIR     Project directory (default: pwd)
  CURB_MAX_ITERATIONS  Max loop iterations (default: 100)
  CURB_DEBUG           Enable debug mode (set to "true")
  CURB_BACKEND         Task backend: "auto", "beads", or "json"
  CURB_BUDGET          Token budget limit for this run
  HARNESS              Harness: "auto", "claude", or "codex"
  CURB_MODEL           Claude model: "opus", "sonnet", or "haiku"
  CURB_EPIC            Filter to tasks within this epic ID
  CURB_LABEL           Filter to tasks with this label
  CLAUDE_FLAGS         Extra flags for Claude Code CLI
  CODEX_FLAGS          Extra flags for OpenAI Codex CLI

Files expected in project:
  .beads/        Beads data directory (if using beads backend)
  prd.json       Task backlog JSON (if using json backend)
  PROMPT.md      Loop prompt template
  AGENT.md       Agent build instructions (AGENTS.md also supported for Codex)
  specs/         Specification files
  progress.txt   Progress log (created automatically)

Beads installation (optional, for beads backend):
  brew install steveyegge/beads/bd
  npm install -g @beads/bd
  go install github.com/steveyegge/beads/cmd/bd@latest
EOF
            ;;
        *)
            validate_project
            run_loop
            ;;
    esac
}

main "$@"
