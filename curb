#!/usr/bin/env bash
#
# curb - Claude Under Ralph + Beads
#
# Autonomous AI coding agent harness that drives Claude Code in a loop
# to build software from a prd.json backlog with beads-style task tracking.
#
# Usage:
#   curb              # Run loop until all tasks complete
#   curb --once       # Run single iteration
#   curb --status     # Show current task status
#   curb --ready      # Show ready tasks
#   curb --plan       # Run in planning mode (generate fix_plan.md)
#   curb --debug      # Enable debug logging (can combine with other flags)
#
set -euo pipefail

CURB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="${CURB_PROJECT_DIR:-$(pwd)}"

# Source task management library
source "${CURB_DIR}/lib/tasks.sh"
# Source harness abstraction layer
source "${CURB_DIR}/lib/harness.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Debug mode (set via --debug flag)
DEBUG="${CURB_DEBUG:-false}"
# Stream mode (set via --stream flag)
STREAM="${CURB_STREAM:-false}"
# Backend mode (set via --backend flag or CURB_BACKEND env)
# Values: "auto", "beads", "json"
BACKEND="${CURB_BACKEND:-auto}"
# Harness (set via --harness flag or HARNESS env)
# Values: "auto", "claude", "codex"
HARNESS="${HARNESS:-auto}"

log_info() { echo -e "${BLUE}[curb]${NC} $1"; }
log_success() { echo -e "${GREEN}[curb]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[curb]${NC} $1"; }
log_error() { echo -e "${RED}[curb]${NC} $1" >&2; }
log_debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${DIM}${CYAN}[debug]${NC}${DIM} $1${NC}" >&2
    fi
}

# Check dependencies
check_deps() {
    local missing=()
    command -v jq >/dev/null 2>&1 || missing+=("jq")

    # Check for at least one harness
    if ! harness_available; then
        missing+=("harness (claude or codex)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}"
        exit 1
    fi

    # Log which harness is active
    log_debug "Harness: $(harness_get)"
}

# Validate project structure
validate_project() {
    log_debug "Validating project structure in ${PROJECT_DIR}"

    # Detect task backend
    local detected_backend
    detected_backend=$(detect_backend "${PROJECT_DIR}")
    log_debug "Task backend: ${detected_backend}"

    if [[ "$detected_backend" == "beads" ]]; then
        log_info "Using beads backend"
        # Beads doesn't need prd.json
    else
        log_info "Using JSON backend (prd.json)"
        if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
            log_error "No prd.json found in ${PROJECT_DIR}"
            log_info "Run 'curb-init' to scaffold a new project"
            exit 1
        fi
        log_debug "Found prd.json ($(wc -c < "${PROJECT_DIR}/prd.json") bytes)"
    fi

    if [[ ! -f "${PROJECT_DIR}/PROMPT.md" ]]; then
        log_warn "No PROMPT.md found, using default template"
        cp "${CURB_DIR}/templates/PROMPT.md" "${PROJECT_DIR}/PROMPT.md"
    fi
    log_debug "Found PROMPT.md ($(wc -l < "${PROJECT_DIR}/PROMPT.md") lines)"

    if [[ ! -f "${PROJECT_DIR}/AGENT.md" ]]; then
        log_warn "No AGENT.md found, using default template"
        cp "${CURB_DIR}/templates/AGENT.md" "${PROJECT_DIR}/AGENT.md"
    fi
    log_debug "Found AGENT.md ($(wc -l < "${PROJECT_DIR}/AGENT.md") lines)"
    log_debug "Project validation complete"
}

# Show task status summary
show_status() {
    local prd="${PROJECT_DIR}/prd.json"

    echo ""
    log_info "Task Status Summary"
    echo "===================="

    local total=$(jq '.tasks | length' "$prd")
    local closed=$(jq '[.tasks[] | select(.status == "closed")] | length' "$prd")
    local in_progress=$(jq '[.tasks[] | select(.status == "in_progress")] | length' "$prd")
    local open=$(jq '[.tasks[] | select(.status == "open")] | length' "$prd")

    echo -e "Total:       ${total}"
    echo -e "Closed:      ${GREEN}${closed}${NC}"
    echo -e "In Progress: ${YELLOW}${in_progress}${NC}"
    echo -e "Open:        ${open}"
    echo ""

    # Show by priority
    log_info "By Priority"
    for p in P0 P1 P2 P3 P4; do
        local count=$(jq --arg p "$p" '[.tasks[] | select(.priority == $p and .status != "closed")] | length' "$prd")
        if [[ "$count" -gt 0 ]]; then
            echo "  ${p}: ${count} remaining"
        fi
    done
    echo ""

    # Progress bar
    if [[ "$total" -gt 0 ]]; then
        local pct=$((closed * 100 / total))
        local filled=$((pct / 5))
        local empty=$((20 - filled))
        printf "Progress: ["
        printf "%0.s#" $(seq 1 $filled 2>/dev/null) || true
        printf "%0.s-" $(seq 1 $empty 2>/dev/null) || true
        printf "] %d%%\n" "$pct"
    fi
}

# Show ready tasks
show_ready() {
    local prd="${PROJECT_DIR}/prd.json"

    log_info "Ready Tasks (unblocked, status=open)"
    echo "======================================"

    local ready=$(get_ready_tasks "$prd")

    if [[ -z "$ready" || "$ready" == "null" ]]; then
        log_warn "No ready tasks found"
        return
    fi

    echo "$ready" | jq -r '.[] | "[\(.priority)] \(.id): \(.title)"'
}

# Generate the system prompt (static instructions from PROMPT.md)
generate_system_prompt() {
    cat "${PROJECT_DIR}/PROMPT.md"
}

# Generate the task prompt (just the current task details - kept short for stdin)
generate_task_prompt() {
    local task_json="$1"

    # Extract task details
    local task_id=$(echo "$task_json" | jq -r '.id')
    local task_title=$(echo "$task_json" | jq -r '.title')
    local task_type=$(echo "$task_json" | jq -r '.type')
    local task_desc=$(echo "$task_json" | jq -r '.description')
    local task_criteria=$(echo "$task_json" | jq -r '.acceptanceCriteria // [] | join("\n- ")')

    # Generate focused task prompt (minimal - just the task)
    cat <<EOF
## CURRENT TASK

Task ID: ${task_id}
Type: ${task_type}
Title: ${task_title}

Description:
${task_desc}

Acceptance Criteria:
- ${task_criteria}

When complete:
1. Run feedback loops (typecheck, test, lint)
2. Update prd.json: set status to "closed" for ${task_id}
3. Commit: ${task_type}(${task_id}): ${task_title}
4. Append learnings to progress.txt
EOF
}

# Run a single iteration
run_iteration() {
    local prd="${PROJECT_DIR}/prd.json"
    log_debug "Starting iteration, reading prd.json"

    # Check for in-progress tasks first (resume interrupted work)
    local current_task
    log_debug "Checking for in-progress tasks..."
    current_task=$(jq '[.tasks[] | select(.status == "in_progress")] | first' "$prd")
    log_debug "In-progress query result: ${current_task:0:100}..."

    if [[ "$current_task" != "null" && -n "$current_task" ]]; then
        local task_id=$(echo "$current_task" | jq -r '.id')
        local task_title=$(echo "$current_task" | jq -r '.title')
        local task_type=$(echo "$current_task" | jq -r '.type')
        log_warn "Resuming in-progress task: ${task_id}"
        log_info "  ${task_type}: ${task_title}"
        log_debug "Task JSON: $current_task"
    else
        # Find next ready task
        log_debug "No in-progress tasks, finding ready tasks..."
        local ready_tasks
        ready_tasks=$(get_ready_tasks "$prd")
        log_debug "Ready tasks result: ${ready_tasks:0:200}..."

        if [[ -z "$ready_tasks" || "$ready_tasks" == "[]" ]]; then
            # Check if we're done
            local open_count=$(jq '[.tasks[] | select(.status != "closed")] | length' "$prd")
            log_debug "Open task count: ${open_count}"
            if [[ "$open_count" -eq 0 ]]; then
                log_success "All tasks complete!"
                return 0
            else
                log_error "No ready tasks but ${open_count} tasks not closed. Check dependencies."
                return 1
            fi
        fi

        # Pick highest priority ready task
        current_task=$(echo "$ready_tasks" | jq 'first')
        local task_id=$(echo "$current_task" | jq -r '.id')
        local task_title=$(echo "$current_task" | jq -r '.title')
        local task_type=$(echo "$current_task" | jq -r '.type')
        local task_priority=$(echo "$current_task" | jq -r '.priority')

        log_info "Selected task: ${task_id} [${task_priority}]"
        log_info "  ${task_type}: ${task_title}"
        log_debug "Task JSON: $current_task"

        # Mark as in_progress
        log_debug "Updating task status to in_progress..."
        update_task_status "$prd" "$task_id" "in_progress"
        log_debug "Task status updated"
    fi

    # Generate prompts
    log_debug "Generating prompts..."
    local system_prompt
    system_prompt=$(generate_system_prompt)
    local task_prompt
    task_prompt=$(generate_task_prompt "$current_task")

    local sys_bytes=$(echo "$system_prompt" | wc -c)
    local task_bytes=$(echo "$task_prompt" | wc -c)
    log_debug "System prompt: ${sys_bytes} bytes (via --append-system-prompt)"
    log_debug "Task prompt: ${task_bytes} bytes (via stdin)"

    # Show prompts in debug mode
    if [[ "$DEBUG" == "true" ]]; then
        echo ""
        log_debug "=== SYSTEM PROMPT ==="
        echo -e "${DIM}$system_prompt${NC}" >&2
        log_debug "=== TASK PROMPT ==="
        echo -e "${DIM}$task_prompt${NC}" >&2
        log_debug "===================="
        echo ""
    fi

    local harness=$(harness_get)
    log_info "Running ${harness}..."
    echo ""

    if [[ "$DEBUG" == "true" ]]; then
        # Pre-flight check
        log_debug "Pre-flight: ${harness} version"
        local version_output
        version_output=$(harness_version 2>&1) && log_debug "Version: ${version_output}" || log_debug "WARNING: version check failed"
        log_debug "Binary: $(which ${harness})"
    fi

    # Run harness with the prompt via abstraction layer
    local start_time=$(date +%s)
    local exit_code=0
    log_debug "Execution start: $(date)"

    if [[ "$DEBUG" == "true" ]]; then
        # Save prompts to temp files for manual testing
        local tmp_sys=$(mktemp)
        local tmp_task=$(mktemp)
        echo "$system_prompt" > "$tmp_sys"
        echo "$task_prompt" > "$tmp_task"
        log_debug "System prompt: ${tmp_sys}"
        log_debug "Task prompt: ${tmp_task}"
        log_debug ">>> Prompts saved for debugging"
        log_debug ""
        log_debug "--- HARNESS START (${harness}) ---"
    fi

    # Invoke harness via abstraction layer
    if [[ "$STREAM" == "true" ]]; then
        log_info "Streaming ${harness} output..."
        harness_invoke_streaming "$system_prompt" "$task_prompt" "$DEBUG"
        exit_code=$?
    else
        harness_invoke "$system_prompt" "$task_prompt" "$DEBUG"
        exit_code=$?
    fi

    if [[ "$DEBUG" == "true" ]]; then
        log_debug "--- HARNESS END (${harness}) ---"

        # Cleanup on success, keep on failure
        if [[ $exit_code -eq 0 ]]; then
            rm -f "$tmp_sys" "$tmp_task"
        else
            log_debug "Keeping prompt files for debugging"
            log_debug "  System: ${tmp_sys}"
            log_debug "  Task: ${tmp_task}"
        fi
    fi

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    log_debug "Execution end: $(date)"
    log_debug "Duration: ${duration} seconds"
    log_debug "Exit code: ${exit_code}"

    if [[ $exit_code -ne 0 ]]; then
        log_warn "Claude Code exited with code ${exit_code}"
        log_debug "Non-zero exit may indicate: timeout, error, or user interrupt"
    else
        log_debug "Claude Code completed successfully"
    fi

    return $exit_code
}

# Run planning mode
run_planning() {
    local prd="${PROJECT_DIR}/prd.json"
    log_debug "Starting planning mode"

    log_info "Running in planning mode..."

    local plan_prompt
    plan_prompt=$(cat <<'EOF'
Study @specs/* for specifications.
Study @prd.json for the current task backlog.
Study the existing source code.

Your task is to analyze the codebase and update @fix_plan.md:

1. Use subagents to study existing source code and compare against specifications
2. Search for TODO comments, placeholder implementations, and missing functionality
3. Create/update fix_plan.md with a prioritized bullet list of items to implement
4. For each item, note:
   - What needs to be done
   - Which files are affected
   - Dependencies on other items
5. If you discover missing specifications, document them

Think hard. Be thorough. Use many parallel subagents for research.
EOF
)

    if [[ "$DEBUG" == "true" ]]; then
        log_debug "Plan prompt: $(echo "$plan_prompt" | wc -l) lines"
        log_debug "=== PLAN PROMPT ==="
        echo -e "${DIM}$plan_prompt${NC}" >&2
        log_debug "==================="
    fi

    local start_time=$(date +%s)
    log_debug "Execution start: $(date)"

    echo "$plan_prompt" | claude -p --dangerously-skip-permissions

    local exit_code=$?
    local end_time=$(date +%s)
    log_debug "Execution end: $(date), duration: $((end_time - start_time))s, exit: ${exit_code}"
}

# Main loop
run_loop() {
    local max_iterations="${CURB_MAX_ITERATIONS:-100}"
    local iteration=0

    log_info "Starting curb loop (max ${max_iterations} iterations)"
    log_debug "Max iterations: ${max_iterations}"
    log_debug "Loop starting at: $(date)"
    echo ""

    while [[ $iteration -lt $max_iterations ]]; do
        iteration=$((iteration + 1))
        log_info "=== Iteration ${iteration} ==="
        log_debug "--- Iteration ${iteration} start: $(date) ---"

        # Check if all tasks complete
        local prd="${PROJECT_DIR}/prd.json"
        log_debug "Querying remaining tasks..."
        local remaining=$(jq '[.tasks[] | select(.status != "closed")] | length' "$prd")
        log_debug "Remaining tasks: ${remaining}"

        if [[ "$remaining" -eq 0 ]]; then
            log_success "All tasks complete! Exiting loop."
            show_status
            return 0
        fi

        # Run single iteration
        log_debug "Calling run_iteration..."
        if ! run_iteration; then
            log_warn "Iteration failed, continuing..."
            log_debug "run_iteration returned non-zero"
        fi

        echo ""
        log_info "Iteration ${iteration} complete. ${remaining} tasks remaining."
        log_debug "--- Iteration ${iteration} end: $(date) ---"
        echo ""

        # Brief pause between iterations to allow for interruption
        log_debug "Sleeping 2 seconds before next iteration..."
        sleep 2
    done

    log_warn "Reached max iterations (${max_iterations})"
    log_debug "Loop terminated at: $(date)"
    show_status
    return 1
}

# Main entry point
main() {
    # Parse flags first (can be combined with other flags)
    local args=()
    for arg in "$@"; do
        if [[ "$arg" == "--debug" || "$arg" == "-d" ]]; then
            DEBUG="true"
            log_debug "Debug mode enabled"
            log_debug "CURB_DIR=${CURB_DIR}"
            log_debug "PROJECT_DIR=${PROJECT_DIR}"
            log_debug "Shell: $SHELL (bash ${BASH_VERSION})"
            log_debug "Date: $(date)"
        elif [[ "$arg" == "--stream" ]]; then
            STREAM="true"
            log_info "Stream mode enabled - showing harness activity"
        elif [[ "$arg" == "--backend="* ]]; then
            BACKEND="${arg#--backend=}"
            export CURB_BACKEND="$BACKEND"
        elif [[ "$arg" == "--backend" ]]; then
            # Next arg is the backend value - handle in next iteration
            _next_is_backend=true
            continue
        elif [[ "${_next_is_backend:-}" == "true" ]]; then
            BACKEND="$arg"
            export CURB_BACKEND="$BACKEND"
            _next_is_backend=false
        elif [[ "$arg" == "--harness="* ]]; then
            HARNESS="${arg#--harness=}"
            export HARNESS
        elif [[ "$arg" == "--harness" ]]; then
            # Next arg is the harness value - handle in next iteration
            _next_is_harness=true
            continue
        elif [[ "${_next_is_harness:-}" == "true" ]]; then
            HARNESS="$arg"
            export HARNESS
            _next_is_harness=false
        else
            args+=("$arg")
        fi
    done
    unset _next_is_backend
    unset _next_is_harness

    check_deps
    log_debug "Dependencies checked: jq and harness found"

    case "${args[0]:-}" in
        --status|-s)
            validate_project
            show_status
            ;;
        --ready|-r)
            validate_project
            show_ready
            ;;
        --once|-1)
            validate_project
            run_iteration
            ;;
        --plan|-p)
            validate_project
            run_planning
            ;;
        --test|-t)
            log_info "Testing Claude Code invocation..."
            log_debug "Binary: $(which claude)"
            log_debug "Version: $(claude --version 2>&1)"
            echo ""
            log_info "Test 1: Simple echo pipe"
            log_debug "Command: echo 'Say hello' | claude -p"
            if echo "Say hello" | claude -p; then
                log_success "Test 1 passed"
            else
                log_error "Test 1 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 2: Heredoc pipe"
            log_debug "Command: claude -p <<< 'Say goodbye'"
            if claude -p <<< "Say goodbye"; then
                log_success "Test 2 passed"
            else
                log_error "Test 2 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 3: Multi-line prompt"
            local test_prompt="You are a helpful assistant.

Say 'curb test successful' and nothing else."
            log_debug "Command: echo \"\$test_prompt\" | claude -p"
            if echo "$test_prompt" | claude -p; then
                log_success "Test 3 passed"
            else
                log_error "Test 3 failed (exit: $?)"
            fi
            echo ""
            log_success "All tests complete"
            ;;
        --migrate-to-beads)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                log_error "No prd.json found to migrate"
                exit 1
            fi
            log_info "Migrating from prd.json to beads..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "false"
            ;;
        --migrate-to-beads-dry-run)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                log_error "No prd.json found to migrate"
                exit 1
            fi
            log_info "DRY RUN: Showing what would be migrated..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "true"
            ;;
        --dump-prompt)
            validate_project
            local prd="${PROJECT_DIR}/prd.json"
            local current_task
            current_task=$(jq '[.tasks[] | select(.status == "in_progress")] | first' "$prd")
            if [[ "$current_task" == "null" || -z "$current_task" ]]; then
                current_task=$(get_ready_tasks "$prd" | jq 'first')
            fi
            if [[ "$current_task" == "null" || -z "$current_task" ]]; then
                log_error "No tasks available"
                exit 1
            fi
            local sys_file="${PROJECT_DIR}/curb_system_prompt.txt"
            local task_file="${PROJECT_DIR}/curb_task_prompt.txt"
            generate_system_prompt > "$sys_file"
            generate_task_prompt "$current_task" > "$task_file"
            log_success "Prompts dumped:"
            log_info "  System: ${sys_file} ($(wc -c < "$sys_file") bytes)"
            log_info "  Task:   ${task_file} ($(wc -c < "$task_file") bytes)"
            log_info ""
            log_info "To test manually:"
            log_info "  claude -p --append-system-prompt \"\$(cat ${sys_file})\" < ${task_file}"
            ;;
        --help|-h)
            cat <<EOF
curb - Claude Under Ralph + Beads

Autonomous AI coding agent that drives coding harnesses (Claude Code or OpenAI
Codex) in a loop.

Usage:
  curb              Run loop until all tasks complete
  curb --once       Run single iteration
  curb --status     Show current task status
  curb --ready      Show ready tasks
  curb --plan       Run in planning mode
  curb --test       Test harness invocation with simple prompts
  curb --dump-prompt  Dump the actual prompt to a file for inspection
  curb --migrate-to-beads      Migrate tasks from prd.json to beads
  curb --migrate-to-beads-dry-run  Preview migration without making changes
  curb --debug      Enable debug logging (can combine with other flags)
  curb --stream     Stream harness activity in real-time (can combine)
  curb --backend X  Force task backend: "beads" or "json" (default: auto-detect)
  curb --harness X  Force harness: "claude" or "codex" (default: auto-detect)

Flags:
  --debug, -d       Enable verbose debug output including:
                    - Full prompt being sent to harness
                    - Task selection details and JSON
                    - Timing information
                    - Saves prompt to temp file for debugging
  --stream          Stream harness activity showing:
                    - Tool calls as they happen
                    - Text responses in real-time
                    - Final result and cost
  --backend <mode>  Task backend selection:
                    - auto: use beads if available, else json (default)
                    - beads: use beads CLI (bd) for task management
                    - json: use prd.json file directly
  --harness <name>  Harness selection:
                    - auto: prefer claude, fall back to codex (default)
                    - claude: use Claude Code CLI
                    - codex: use OpenAI Codex CLI

Environment:
  CURB_PROJECT_DIR     Project directory (default: pwd)
  CURB_MAX_ITERATIONS  Max loop iterations (default: 100)
  CURB_DEBUG           Enable debug mode (set to "true")
  CURB_BACKEND         Task backend: "auto", "beads", or "json"
  HARNESS              Harness: "auto", "claude", or "codex"
  CLAUDE_FLAGS         Extra flags for Claude Code CLI
  CODEX_FLAGS          Extra flags for OpenAI Codex CLI

Files expected in project:
  .beads/        Beads data directory (if using beads backend)
  prd.json       Task backlog JSON (if using json backend)
  PROMPT.md      Loop prompt template
  AGENT.md       Agent build instructions (AGENTS.md also supported for Codex)
  specs/         Specification files
  progress.txt   Progress log (created automatically)

Beads installation (optional, for beads backend):
  brew install steveyegge/beads/bd
  npm install -g @beads/bd
  go install github.com/steveyegge/beads/cmd/bd@latest
EOF
            ;;
        *)
            validate_project
            run_loop
            ;;
    esac
}

main "$@"
