#!/usr/bin/env bash
#
# curb - Claude Under Ralph + Beads
#
# Autonomous AI coding agent harness that drives Claude Code in a loop
# to build software from a prd.json backlog with beads-style task tracking.
#
# Usage:
#   curb              # Run loop until all tasks complete
#   curb --once       # Run single iteration
#   curb --status     # Show current task status
#   curb --ready      # Show ready tasks
#   curb --plan       # Run in planning mode (generate fix_plan.md)
#   curb --budget 1000000  # Set token budget for run
#   curb --debug      # Enable debug logging (can combine with other flags)
#
set -euo pipefail

# Version information
CURB_VERSION="1.0.0"

CURB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="${CURB_PROJECT_DIR:-$(pwd)}"

# Source task management library
source "${CURB_DIR}/lib/tasks.sh"
# Source harness abstraction layer
source "${CURB_DIR}/lib/harness.sh"
# Source XDG directory helpers
source "${CURB_DIR}/lib/xdg.sh"
# Source configuration management
source "${CURB_DIR}/lib/config.sh"
# Source logger
source "${CURB_DIR}/lib/logger.sh"
# Source git operations
source "${CURB_DIR}/lib/git.sh"
# Source state verification
source "${CURB_DIR}/lib/state.sh"
# Source budget tracking
source "${CURB_DIR}/lib/budget.sh"
# Source hooks framework
source "${CURB_DIR}/lib/hooks.sh"
# Source session management
source "${CURB_DIR}/lib/session.sh"
# Source artifacts management
source "${CURB_DIR}/lib/artifacts.sh"

# Load configuration early
config_load

# Version subcommand
cmd_version() {
    echo "curb v${CURB_VERSION}"
    return 0
}

# Show help for init subcommand
cmd_init_help() {
    cat <<'EOF'
curb init [--global] [<directory>]

Initialize curb in a project or globally.

USAGE:
  curb init              Initialize in current directory
  curb init --global    Set up global configuration
  curb init <dir>       Initialize in specific directory

OPTIONS:
  --global              Set up global configuration (~/.config/curb)
                        Creates config templates and hook directories.
                        Only needs to run once per system.

  <directory>           Directory to initialize (default: current dir)
                        Creates prd.json, PROMPT.md, AGENT.md, etc.

WHAT IT CREATES:
  prd.json              Task backlog in JSON format
  PROMPT.md             System prompt template
  AGENT.md              Build/run instructions
  progress.txt          Progress tracking (auto-updated)
  fix_plan.md           Issue tracking (auto-updated)
  .gitignore            With curb patterns

GLOBAL SETUP:
  ~/.config/curb/config.json       Configuration defaults
  ~/.config/curb/hooks/            Hook directories

EXAMPLES:
  # Initialize in current directory
  curb init

  # Initialize specific project
  curb init ~/my-project

  # Set up system-wide defaults
  curb init --global

  # Then initialize a project
  curb init ~/my-project

SEE ALSO:
  curb --help       Show all commands
  curb status       Check project status
EOF
}

# Init subcommand - initialize a project
cmd_init() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_init_help
        return 0
    fi

    # Parse flags
    local global_init=false
    if [[ "${1:-}" == "--global" ]]; then
        global_init=true
        shift
    fi

    local target_dir="${1:-.}"

    # ============================================================================
    # Global initialization (--global flag)
    # ============================================================================
    if [[ "$global_init" == "true" ]]; then
        log_info "Initializing global curb configuration"
        echo ""

        # Check dependencies
        log_info "Checking dependencies..."
        local missing_deps=()

        # Check for jq
        if ! command -v jq >/dev/null 2>&1; then
            missing_deps+=("jq")
            _log_error_console "Missing dependency: jq"
            echo "  Install with: brew install jq (macOS) or apt-get install jq (Linux)"
        else
            log_success "Found jq"
        fi

        # Check for at least one harness
        local harness_found=false
        if command -v claude >/dev/null 2>&1; then
            log_success "Found claude harness"
            harness_found=true
        fi
        if command -v codex >/dev/null 2>&1; then
            log_success "Found codex harness"
            harness_found=true
        fi

        if [[ "$harness_found" == "false" ]]; then
            missing_deps+=("harness (claude or codex)")
            _log_error_console "No harness found (need claude or codex)"
            echo "  Install Claude Code: https://claude.com/claude-code"
            echo "  Or Codex: npm install -g @anthropic/codex"
        fi

        # Exit if dependencies missing
        if [[ ${#missing_deps[@]} -gt 0 ]]; then
            echo ""
            _log_error_console "Missing required dependencies. Please install them and try again."
            return 1
        fi

        echo ""
        log_info "Creating global directory structure..."

        # Create XDG directories
        curb_ensure_dirs

        local config_dir
        config_dir="$(curb_config_dir)"
        local config_file="${config_dir}/config.json"
        local hooks_dir="${config_dir}/hooks"

        log_success "Created ${config_dir}"
        log_success "Created $(curb_logs_dir)"
        log_success "Created $(curb_cache_dir)"

        # Create config file with sensible defaults
        log_info "Creating default configuration..."

        if [[ -f "$config_file" ]]; then
            log_warn "Config file already exists at ${config_file}"
            log_warn "Skipping config creation (remove file to recreate)"
        else
            cat > "$config_file" <<'EOF'
{
  "harness": {
    "default": "auto",
    "priority": ["claude", "gemini", "codex", "opencode"]
  },
  "budget": {
    "default": 1000000,
    "warn_at": 0.8
  },
  "loop": {
    "max_iterations": 100
  },
  "clean_state": {
    "require_commit": true,
    "require_tests": false
  },
  "hooks": {
    "enabled": true
  }
}
EOF
            log_success "Created ${config_file}"
        fi

        # Create hook directories
        log_info "Creating hook directories..."

        local hook_types=("pre-loop" "pre-task" "post-task" "on-error" "post-loop")
        for hook_type in "${hook_types[@]}"; do
            local hook_dir="${hooks_dir}/${hook_type}.d"
            if [[ ! -d "$hook_dir" ]]; then
                mkdir -p "$hook_dir"
                log_success "Created ${hook_dir}"
            else
                log_warn "${hook_dir} already exists"
            fi
        done

        echo ""
        log_success "Global curb configuration complete!"
        echo ""
        echo "Configuration:"
        echo "  Config file:  ${config_file}"
        echo "  Hooks:        ${hooks_dir}"
        echo "  Logs:         $(curb_logs_dir)"
        echo ""
        echo "Next steps:"
        echo "  1. Review and customize ${config_file}"
        echo "  2. Add custom hooks to ${hooks_dir}/<hook-type>.d/"
        echo "  3. Initialize a project with: curb init <project-dir>"
        echo "  4. Start building: cd <project-dir> && curb"
        echo ""
        echo "Configuration options:"
        echo "  harness.default       - Default harness to use (auto|claude|codex)"
        echo "  harness.priority      - Order to try harnesses when auto"
        echo "  budget.default        - Default token budget per run"
        echo "  loop.max_iterations   - Maximum iterations before stopping"
        echo "  clean_state.require_commit - Require harness to commit changes"
        echo ""

        return 0
    fi

    # ============================================================================
    # Project initialization (default behavior)
    # ============================================================================

    # Get project name from directory
    local project_name
    project_name=$(basename "$(cd "$target_dir" && pwd)")
    local prefix
    prefix=$(echo "$project_name" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]' | head -c 8)
    [[ -z "$prefix" ]] && prefix="prd"

    log_info "Initializing curb in: ${target_dir}"
    log_info "Project prefix: ${prefix}"

    cd "$target_dir" || return 1

    # Create specs directory
    if [[ ! -d "specs" ]]; then
        mkdir -p specs
        log_success "Created specs/"
    fi

    # Create prd.json if not exists
    if [[ ! -f "prd.json" ]]; then
        cat > prd.json <<EOF
{
  "projectName": "${project_name}",
  "branchName": "feature/${project_name}",
  "prefix": "${prefix}",
  "tasks": [
    {
      "id": "${prefix}-init",
      "type": "task",
      "title": "Project initialization",
      "description": "Set up the initial project structure and configuration",
      "acceptanceCriteria": [
        "Project builds successfully",
        "Basic structure in place",
        "typecheck passes",
        "tests pass (or test framework configured)"
      ],
      "priority": "P0",
      "status": "open",
      "dependsOn": [],
      "notes": ""
    }
  ]
}
EOF
        log_success "Created prd.json with initial task"
    else
        log_warn "prd.json already exists, skipping"
    fi

    # Create PROMPT.md
    if [[ ! -f "PROMPT.md" ]]; then
        cp "${CURB_DIR}/templates/PROMPT.md" PROMPT.md
        log_success "Created PROMPT.md"
    else
        log_warn "PROMPT.md already exists, skipping"
    fi

    # Create AGENT.md
    if [[ ! -f "AGENT.md" ]]; then
        cp "${CURB_DIR}/templates/AGENT.md" AGENT.md
        log_success "Created AGENT.md"
    else
        log_warn "AGENT.md already exists, skipping"
    fi

    # Create AGENTS.md symlink for Codex compatibility
    # Codex CLI looks for AGENTS.md in the project root
    if [[ ! -f "AGENTS.md" && ! -L "AGENTS.md" ]]; then
        ln -s AGENT.md AGENTS.md
        log_success "Created AGENTS.md symlink (for Codex compatibility)"
    elif [[ -L "AGENTS.md" ]]; then
        log_warn "AGENTS.md symlink already exists, skipping"
    else
        log_warn "AGENTS.md already exists as file, skipping symlink"
    fi

    # Create progress.txt
    if [[ ! -f "progress.txt" ]]; then
        cat > progress.txt <<EOF
# Progress Log
Started: $(date -u +"%Y-%m-%d")

## Codebase Patterns
<!-- Agent adds discovered patterns here for future iterations -->

## Key Files
<!-- Important files to be aware of -->

---
EOF
        log_success "Created progress.txt"
    else
        log_warn "progress.txt already exists, skipping"
    fi

    # Create fix_plan.md
    if [[ ! -f "fix_plan.md" ]]; then
        cat > fix_plan.md <<EOF
# Fix Plan

Discovered issues and planned improvements.
Agent maintains this file during development.

## High Priority

## Medium Priority

## Low Priority

## Completed
EOF
        log_success "Created fix_plan.md"
    else
        log_warn "fix_plan.md already exists, skipping"
    fi

    # Create .gitignore additions
    if [[ -f ".gitignore" ]]; then
        if ! grep -q "# Curb" .gitignore 2>/dev/null; then
            cat >> .gitignore <<EOF

# Curb
*.curb.tmp
EOF
            log_success "Updated .gitignore"
        fi
    else
        cat > .gitignore <<EOF
# Curb
*.curb.tmp
EOF
        log_success "Created .gitignore"
    fi

    echo ""
    log_success "Curb initialized!"
    echo ""
    echo "Next steps:"
    echo "  1. Edit prd.json to add your tasks (use ChatPRD template output)"
    echo "  2. Add specifications to specs/"
    echo "  3. Update AGENT.md with build instructions"
    echo "  4. Run 'curb status' to see task summary"
    echo "  5. Run 'curb' to start the autonomous loop"
    echo ""
    echo "Useful commands:"
    echo "  curb status        Show task progress"
    echo "  curb run --ready   Show ready tasks"
    echo "  curb run --once    Run single iteration"
    echo "  curb run --plan    Run planning mode"
    echo "  curb --harness codex Use OpenAI Codex instead of Claude"
    echo ""

    return 0
}

# Show help for run subcommand
cmd_run_help() {
    cat <<'EOF'
curb run [<options>]

Run the autonomous coding loop to complete tasks.

USAGE:
  curb run              Run continuous loop (default behavior)
  curb run --once       Run exactly one iteration then exit
  curb run --ready      Show ready (unblocked) tasks without running
  curb run --plan       Run planning mode to analyze codebase

EXECUTION OPTIONS:
  --once, -1            Run single iteration then exit
  --ready, -r           List tasks ready to work on
  --plan, -p            Generate fix_plan.md with code analysis
  --push                Push completed work to remote (experimental)

FILTERING:
  --epic <id>           Only work on tasks in this epic
  --label <name>        Only work on tasks with this label

MODEL & HARNESS:
  --model <name>        Claude model: opus, sonnet, haiku
  --harness <name>      AI harness: claude, codex, gemini, opencode

RELIABILITY:
  --require-clean       Force clean git state before starting
  --no-require-clean    Disable clean state check

BUDGET & LIMITS:
  --budget <tokens>     Token budget limit (e.g., 1000000)
  --name <name>         Session name for tracking

DEBUG:
  --debug, -d           Show detailed execution logs
  --stream              Stream harness output in real-time

EXAMPLES:
  # Run continuous loop
  curb run

  # Run once with budget limit
  curb run --once --budget 1000000

  # View ready tasks without running
  curb run --ready

  # Work on specific epic only
  curb run --epic backend-v2

  # Use Sonnet with live output
  curb run --model sonnet --stream

  # Run with detailed debugging
  curb run --once --debug

SEE ALSO:
  curb --help       Show all commands
  curb status       Check current progress
  curb artifacts    Access task output files
EOF
}

# Run subcommand - run the main loop
cmd_run() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_run_help
        return 0
    fi

    # Parse run-specific flags
    local args=()
    local run_once=false
    local run_plan=false
    local run_ready=false

    # Local copies of flag variables (can be overridden per-run)
    local cmd_epic="${EPIC}"
    local cmd_label="${LABEL}"
    local cmd_model="${MODEL}"
    local cmd_budget="${BUDGET}"
    local cmd_require_clean="${REQUIRE_CLEAN}"
    local cmd_session_name="${SESSION_NAME}"
    local cmd_push=false

    for arg in "$@"; do
        case "$arg" in
            --once|-1)
                run_once=true
                ;;
            --plan|-p)
                run_plan=true
                ;;
            --ready|-r)
                run_ready=true
                ;;
            --push)
                cmd_push=true
                ;;
            --require-clean)
                cmd_require_clean="true"
                export CURB_REQUIRE_CLEAN="true"
                log_info "Clean state enforcement enabled via CLI flag"
                ;;
            --no-require-clean)
                cmd_require_clean="false"
                export CURB_REQUIRE_CLEAN="false"
                log_info "Clean state enforcement disabled via CLI flag"
                ;;
            --model=*)
                cmd_model="${arg#--model=}"
                export CURB_MODEL="$cmd_model"
                ;;
            --model)
                _next_is_model=true
                ;;
            --epic=*)
                cmd_epic="${arg#--epic=}"
                export CURB_EPIC="$cmd_epic"
                ;;
            --epic)
                _next_is_epic=true
                ;;
            --label=*)
                cmd_label="${arg#--label=}"
                export CURB_LABEL="$cmd_label"
                ;;
            --label)
                _next_is_label=true
                ;;
            --budget=*)
                cmd_budget="${arg#--budget=}"
                export CURB_BUDGET="$cmd_budget"
                ;;
            --budget)
                _next_is_budget=true
                ;;
            --name=*)
                cmd_session_name="${arg#--name=}"
                export CURB_SESSION_NAME="$cmd_session_name"
                ;;
            --name)
                _next_is_name=true
                ;;
            *)
                # Handle deferred flag values
                if [[ "${_next_is_model:-}" == "true" ]]; then
                    cmd_model="$arg"
                    export CURB_MODEL="$cmd_model"
                    _next_is_model=false
                elif [[ "${_next_is_epic:-}" == "true" ]]; then
                    cmd_epic="$arg"
                    export CURB_EPIC="$cmd_epic"
                    _next_is_epic=false
                elif [[ "${_next_is_label:-}" == "true" ]]; then
                    cmd_label="$arg"
                    export CURB_LABEL="$cmd_label"
                    _next_is_label=false
                elif [[ "${_next_is_budget:-}" == "true" ]]; then
                    cmd_budget="$arg"
                    export CURB_BUDGET="$cmd_budget"
                    _next_is_budget=false
                elif [[ "${_next_is_name:-}" == "true" ]]; then
                    cmd_session_name="$arg"
                    export CURB_SESSION_NAME="$cmd_session_name"
                    _next_is_name=false
                else
                    args+=("$arg")
                fi
                ;;
        esac
    done

    # Clean up flag parsing state
    unset _next_is_model
    unset _next_is_epic
    unset _next_is_label
    unset _next_is_budget
    unset _next_is_name

    # Update global variables if they were set via cmd_run flags
    EPIC="$cmd_epic"
    LABEL="$cmd_label"
    MODEL="$cmd_model"
    BUDGET="$cmd_budget"
    REQUIRE_CLEAN="$cmd_require_clean"
    SESSION_NAME="$cmd_session_name"
    PUSH="$cmd_push"

    # Initialize budget if provided via CLI, environment, or config
    # Get budget from: CLI flag > environment > config file
    local budget_limit="${BUDGET:-$(config_get_or "budget.limit" "")}"
    if [[ -n "$budget_limit" ]]; then
        if budget_init "$budget_limit"; then
            log_info "Budget initialized: ${budget_limit} tokens"
        else
            log_warn "Failed to initialize budget with value: ${budget_limit}"
        fi
    fi

    validate_project

    # Execute based on mode
    if [[ "$run_ready" == "true" ]]; then
        show_ready
    elif [[ "$run_plan" == "true" ]]; then
        run_planning
    elif [[ "$run_once" == "true" ]]; then
        run_iteration
    else
        run_loop
    fi
}

# Show help for status subcommand
cmd_status_help() {
    cat <<'EOF'
curb status [--json]

Display current task progress and status summary.

USAGE:
  curb status           Show formatted status summary
  curb status --json    Output status as machine-readable JSON

OUTPUT:
  When run without --json:
    - Task counts (total, closed, in progress, open)
    - Progress bar showing percentage complete
    - Current session information (if running)
    - Most recent run details

  When run with --json:
    - Machine-readable JSON with task counts
    - Current session object (if initialized)
    - Most recent run information

EXAMPLES:
  # Show human-readable status
  curb status

  # Check progress before running
  curb status

  # Get JSON for scripting
  curb status --json | jq '.task_counts'

  # Monitor while loop runs in background
  watch -n 5 'curb status'

SEE ALSO:
  curb run --ready    List tasks ready to work on
  curb --help         Show all commands
  curb artifacts      Access task output files
EOF
}

# Status subcommand - show task status
cmd_status() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_status_help
        return 0
    fi

    local json_output=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_output=true
                shift
                ;;
            *)
                _log_error_console "Unknown flag: $1"
                _log_error_console "Usage: curb status [--json]"
                return 1
                ;;
        esac
    done

    # In JSON mode, suppress logging during validation
    if [[ "$json_output" == "true" ]]; then
        validate_project >/dev/null 2>&1
        show_status_json
    else
        validate_project
        show_status
    fi
}

# Show help for explain subcommand
cmd_explain_help() {
    cat <<'EOF'
curb explain <task-id>

Show detailed information about a specific task.

USAGE:
  curb explain <task-id>    Display full task details

OUTPUT INCLUDES:
  - Task ID and title
  - Task type (task, feature, bugfix, etc)
  - Current status (open, in_progress, closed, failed)
  - Priority level
  - Full description
  - Acceptance criteria
  - Dependencies (tasks that must be completed first)
  - Labels and other metadata

EXAMPLES:
  # View task details
  curb explain curb-018

  # Look up a task's requirements
  curb explain backend-001

  # Check task dependencies
  curb explain feature-42

  # Verify acceptance criteria for a task
  curb explain my-project-15

SEE ALSO:
  curb status      Check overall progress
  curb run --ready List ready tasks
  curb --help      Show all commands
EOF
}

# Explain subcommand - show details about a task or session
cmd_explain() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_explain_help
        return 0
    fi

    local target="${1:-}"
    if [[ -z "$target" ]]; then
        _log_error_console "Usage: curb explain <task-id>"
        return 1
    fi

    # Check if it's a task ID or session ID
    local backend=$(get_backend "${PROJECT_DIR}")

    # Try to get task first
    local prd="${PROJECT_DIR}/prd.json"
    local task
    task=$(get_task "$prd" "$target" 2>/dev/null)

    if [[ -n "$task" && "$task" != "null" ]]; then
        # Found a task - show task details
        echo "$task" | jq -r '
            "Task: \(.id)",
            "Title: \(.title)",
            "Type: \(.type)",
            "Status: \(.status)",
            "Priority: \(.priority // "normal")",
            "",
            "Description:",
            "\(.description)",
            "",
            (if .acceptanceCriteria then "Acceptance Criteria:\n- " + (.acceptanceCriteria | join("\n- ")) else "" end),
            (if .dependsOn then "\nDepends on: " + (.dependsOn | join(", ")) else "" end),
            (if .labels then "\nLabels: " + (.labels | join(", ")) else "" end)
        '
    else
        # Not a task, maybe a session? (future implementation)
        _log_error_console "Task or session not found: ${target}"
        return 1
    fi
}

# Show help for artifacts subcommand
cmd_artifacts_help() {
    cat <<'EOF'
curb artifacts [<task-id>]

Access and navigate to task artifact directories and output files.

USAGE:
  curb artifacts              List recent tasks with artifact paths
  curb artifacts <task-id>    Show path to specific task artifacts
  curb artifacts <prefix>     Find tasks by ID prefix (partial match)

TASK ARTIFACTS INCLUDE:
  - task.json              Task metadata and status
  - summary.md             Execution summary
  - changes.patch          Git diff of changes made
  - logs/                  Detailed execution logs
  - run.json               Run-level information

EXAMPLES:
  # List all recent tasks
  curb artifacts

  # Get path to specific task (useful for scripts)
  curb artifacts curb-018
  # Output: .curb/runs/panda-20260110-141339/tasks/curb-018

  # Use in shell command
  cd $(curb artifacts curb-018)
  cat summary.md

  # Find by prefix (shows matches if ambiguous)
  curb artifacts curb-01

  # View recent task summary
  cat $(curb artifacts curb-017)/summary.md

  # Examine git changes made by task
  patch -p1 -R < $(curb artifacts curb-016)/changes.patch

  # Find task logs
  ls $(curb artifacts curb-015)/logs/

SEE ALSO:
  curb status      Check task progress
  curb --help      Show all commands
EOF
}

# Artifacts subcommand - manage artifacts
cmd_artifacts() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_artifacts_help
        return 0
    fi

    local artifacts_base=".curb/runs"

    # If no arguments given, list recent tasks with paths
    if [[ $# -eq 0 ]]; then
        if [[ ! -d "$artifacts_base" ]]; then
            log_info "No artifacts found"
            return 0
        fi

        log_info "Recent tasks:"
        # Find all task directories, sort by modification time (newest first)
        find "$artifacts_base" -maxdepth 3 -type d -name "curb-*" | sort -r | while read -r task_dir; do
            if [[ -f "$task_dir/task.json" ]]; then
                local task_id=$(basename "$task_dir")
                echo "  ${task_id}: ${task_dir}"
            fi
        done
        return 0
    fi

    # Find a task by task_id (supports prefix matching)
    local search_id="$1"
    local artifacts_base=".curb/runs"

    if [[ ! -d "$artifacts_base" ]]; then
        _log_error_console "No artifacts found (no runs yet)"
        return 1
    fi

    # Search for matching task_id across all runs
    # Support both exact and prefix matches
    local matches=()
    while IFS= read -r task_dir; do
        if [[ -f "$task_dir/task.json" ]]; then
            local task_id=$(basename "$task_dir")
            # Check for exact match first, or prefix match
            if [[ "$task_id" == "$search_id" ]] || [[ "$task_id" == "$search_id"* ]]; then
                matches+=("$task_dir")
            fi
        fi
    done < <(find "$artifacts_base" -maxdepth 3 -type d -name "curb-*" 2>/dev/null)

    if [[ ${#matches[@]} -eq 0 ]]; then
        _log_error_console "Task not found: ${search_id}"
        _log_error_console "Tip: Run 'curb artifacts' to see available tasks"
        return 1
    fi

    if [[ ${#matches[@]} -eq 1 ]]; then
        # Single match - print the path
        echo "${matches[0]}"
        return 0
    fi

    # Multiple matches - show them and ask user to be more specific
    _log_error_console "Ambiguous task ID '${search_id}' matches ${#matches[@]} tasks:"
    for match in "${matches[@]}"; do
        _log_error_console "  $(basename "$match"): ${match}"
    done
    _log_error_console "Please use a more specific prefix"
    return 1
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Debug mode (set via --debug flag)
DEBUG="${CURB_DEBUG:-false}"
# Stream mode (set via --stream flag)
STREAM="${CURB_STREAM:-false}"
# Backend mode (set via --backend flag or CURB_BACKEND env)
# Values: "auto", "beads", "json"
BACKEND="${CURB_BACKEND:-auto}"
# Harness (set via --harness flag, HARNESS env, or config file)
# Values: "auto", "claude", "codex", "opencode", "gemini"
# Priority: CLI flag > env var > config harness.priority > default (claude > opencode > codex > gemini)
HARNESS="${HARNESS:-$(config_get_or "harness.default" "auto")}"
# Model (set via --model flag or CURB_MODEL env)
# Values: "opus", "sonnet", "haiku" (only applies to claude harness)
MODEL="${CURB_MODEL:-}"
# Epic filter (set via --epic flag or CURB_EPIC env)
EPIC="${CURB_EPIC:-}"
# Label filter (set via --label flag or CURB_LABEL env)
LABEL="${CURB_LABEL:-}"
# Budget (set via --budget flag, CURB_BUDGET env, or config file)
BUDGET="${CURB_BUDGET:-}"
# Require clean state (set via --require-clean flag or config)
# Empty means use config default, "true"/"false" overrides config
REQUIRE_CLEAN="${CURB_REQUIRE_CLEAN:-}"
# Session name (set via --name flag or CURB_SESSION_NAME env)
SESSION_NAME="${CURB_SESSION_NAME:-}"
# Push flag (set via --push flag)
# Values: "true" or "false"
PUSH="${CURB_PUSH:-false}"

log_info() { echo -e "${BLUE}[curb]${NC} $1"; }
log_success() { echo -e "${GREEN}[curb]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[curb]${NC} $1"; }
_log_error_console() { echo -e "${RED}[curb]${NC} $1" >&2; }
log_debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${DIM}${CYAN}[debug]${NC}${DIM} $1${NC}" >&2
    fi
}

# Deprecation warning helper
warn_deprecated_flag() {
    local old_flag="$1"
    local new_syntax="$2"

    # Check if deprecation warnings are suppressed
    if [[ "${CURB_NO_DEPRECATION_WARNINGS:-}" == "1" ]]; then
        return 0
    fi

    echo -e "${YELLOW}[curb]${NC} Warning: ${old_flag} is deprecated, use: ${new_syntax}" >&2
}

# Check dependencies
check_deps() {
    local missing=()
    command -v jq >/dev/null 2>&1 || missing+=("jq")

    # Check for at least one harness
    if ! harness_available; then
        missing+=("harness (claude or codex)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        _log_error_console "Missing dependencies: ${missing[*]}"
        exit 1
    fi

    # Log which harness is active
    local current_harness
    current_harness=$(harness_get)
    log_debug "Harness: ${current_harness}"

    # Log harness capabilities in debug mode
    if [[ "$DEBUG" == "true" ]]; then
        log_debug "Harness capabilities:"
        if harness_supports "streaming"; then
            log_debug "  - streaming: yes"
        else
            log_debug "  - streaming: no (will use non-streaming mode)"
        fi
        if harness_supports "token_reporting"; then
            log_debug "  - token_reporting: yes"
        else
            log_debug "  - token_reporting: no (will estimate from cost)"
        fi
        if harness_supports "system_prompt"; then
            log_debug "  - system_prompt: yes"
        else
            log_debug "  - system_prompt: no (will combine prompts)"
        fi
        if harness_supports "auto_mode"; then
            log_debug "  - auto_mode: yes"
        else
            log_debug "  - auto_mode: no (may require manual approval)"
        fi
    fi
}

# Validate project structure
validate_project() {
    log_debug "Validating project structure in ${PROJECT_DIR}"

    # Detect and initialize task backend
    # Note: tasks.sh is already sourced at top of script, defining _TASK_BACKEND global
    # detect_backend echoes the result AND sets _TASK_BACKEND, but command substitution
    # runs in subshell, so we explicitly set the global after getting the value
    local detected_backend
    detected_backend=$(detect_backend "${PROJECT_DIR}")
    _TASK_BACKEND="$detected_backend"  # Explicitly set global to persist across function calls
    log_debug "Task backend: ${detected_backend}"

    if [[ "$detected_backend" == "beads" ]]; then
        log_info "Using beads backend"
        # Beads doesn't need prd.json
    else
        log_info "Using JSON backend (prd.json)"
        if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
            _log_error_console "No prd.json found in ${PROJECT_DIR}"
            log_info "Run 'curb-init' to scaffold a new project"
            exit 1
        fi
        log_debug "Found prd.json ($(wc -c < "${PROJECT_DIR}/prd.json") bytes)"
    fi

    if [[ ! -f "${PROJECT_DIR}/PROMPT.md" ]]; then
        log_warn "No PROMPT.md found, using default template"
        cp "${CURB_DIR}/templates/PROMPT.md" "${PROJECT_DIR}/PROMPT.md"
    fi
    log_debug "Found PROMPT.md ($(wc -l < "${PROJECT_DIR}/PROMPT.md") lines)"

    if [[ ! -f "${PROJECT_DIR}/AGENT.md" ]]; then
        log_warn "No AGENT.md found, using default template"
        cp "${CURB_DIR}/templates/AGENT.md" "${PROJECT_DIR}/AGENT.md"
    fi
    log_debug "Found AGENT.md ($(wc -l < "${PROJECT_DIR}/AGENT.md") lines)"
    log_debug "Project validation complete"
}

# Show task status summary
show_status() {
    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend "${PROJECT_DIR}")

    # Validate JSON before processing (only for json backend)
    if [[ "$backend" == "json" ]]; then
        if ! jq empty "$prd" 2>/dev/null; then
            _log_error_console "Invalid JSON in prd.json"
            return 1
        fi
    fi

    echo ""
    log_info "Task Status Summary"
    echo "===================="

    local counts
    counts=$(get_task_counts "$prd")
    local total=$(echo "$counts" | jq -r '.total')
    local closed=$(echo "$counts" | jq -r '.closed')
    local in_progress=$(echo "$counts" | jq -r '.in_progress')
    local open=$(echo "$counts" | jq -r '.open')

    echo -e "Total:       ${total}"
    echo -e "Closed:      ${GREEN}${closed}${NC}"
    echo -e "In Progress: ${YELLOW}${in_progress}${NC}"
    echo -e "Open:        ${open}"
    echo ""

    # Progress bar
    if [[ "$total" -gt 0 ]]; then
        local pct=$((closed * 100 / total))
        local filled=$((pct / 5))
        local empty=$((20 - filled))
        printf "Progress: ["
        printf "%0.s#" $(seq 1 $filled 2>/dev/null) || true
        printf "%0.s-" $(seq 1 $empty 2>/dev/null) || true
        printf "] %d%%\n" "$pct"
    fi

    # Show current session if running
    if session_is_initialized; then
        local session_name
        session_name=$(session_get_name 2>/dev/null || echo "unknown")
        local session_id
        session_id=$(session_get_id 2>/dev/null || echo "unknown")
        echo ""
        log_info "Current Session"
        echo "===================="
        echo "Name: ${session_name}"
        echo "ID:   ${session_id}"
    fi

    # Show most recent run
    local artifacts_base="${PROJECT_DIR}/.curb/runs"
    if [[ -d "$artifacts_base" ]]; then
        local most_recent_run
        most_recent_run=$(ls -t "$artifacts_base" 2>/dev/null | head -n 1)
        if [[ -n "$most_recent_run" ]]; then
            echo ""
            log_info "Most Recent Run"
            echo "===================="
            echo "Run ID: ${most_recent_run}"
            if [[ -f "$artifacts_base/$most_recent_run/run.json" ]]; then
                local started_at
                started_at=$(jq -r '.started_at // "unknown"' "$artifacts_base/$most_recent_run/run.json" 2>/dev/null || echo "unknown")
                local status
                status=$(jq -r '.status // "unknown"' "$artifacts_base/$most_recent_run/run.json" 2>/dev/null || echo "unknown")
                echo "Started: ${started_at}"
                echo "Status:  ${status}"
                echo "Path:    ${artifacts_base}/${most_recent_run}"
            fi
        fi
    fi
}

# Show status in JSON format
show_status_json() {
    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend "${PROJECT_DIR}")

    # Validate JSON before processing (only for json backend)
    if [[ "$backend" == "json" ]]; then
        if ! jq empty "$prd" 2>/dev/null; then
            _log_error_console "Invalid JSON in prd.json"
            return 1
        fi
    fi

    local counts
    counts=$(get_task_counts "$prd")

    # Build JSON output
    local session_name="null"
    local session_id="null"
    if session_is_initialized; then
        session_name="\"$(session_get_name 2>/dev/null || echo "unknown")\""
        session_id="\"$(session_get_id 2>/dev/null || echo "unknown")\""
    fi

    local most_recent_run="null"
    local artifacts_base="${PROJECT_DIR}/.curb/runs"
    if [[ -d "$artifacts_base" ]]; then
        local run_dir
        run_dir=$(ls -t "$artifacts_base" 2>/dev/null | head -n 1)
        if [[ -n "$run_dir" ]]; then
            local started_at="unknown"
            local status="unknown"
            local run_path="${artifacts_base}/${run_dir}"
            if [[ -f "$run_path/run.json" ]]; then
                started_at=$(jq -r '.started_at // "unknown"' "$run_path/run.json" 2>/dev/null || echo "unknown")
                status=$(jq -r '.status // "unknown"' "$run_path/run.json" 2>/dev/null || echo "unknown")
            fi
            most_recent_run=$(jq -n \
                --arg id "$run_dir" \
                --arg started "$started_at" \
                --arg status "$status" \
                --arg path "$run_path" \
                '{id: $id, started_at: $started, status: $status, path: $path}')
        fi
    fi

    # Output JSON
    jq -n \
        --argjson counts "$counts" \
        --argjson session_name "$session_name" \
        --argjson session_id "$session_id" \
        --argjson most_recent_run "$most_recent_run" \
        '{
            task_counts: $counts,
            current_session: (if $session_name != null then {name: $session_name, id: $session_id} else null end),
            most_recent_run: $most_recent_run
        }'
}

# Show ready tasks
show_ready() {
    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend "${PROJECT_DIR}")

    # Validate JSON before processing (only for json backend)
    if [[ "$backend" == "json" ]]; then
        if ! jq empty "$prd" 2>/dev/null; then
            _log_error_console "Invalid JSON in prd.json"
            return 1
        fi
    fi

    log_info "Ready Tasks (unblocked, status=open)"
    if [[ -n "$EPIC" ]]; then
        log_info "  Epic filter: $EPIC"
    fi
    if [[ -n "$LABEL" ]]; then
        log_info "  Label filter: $LABEL"
    fi
    echo "======================================"

    local ready=$(get_ready_tasks "$prd" "$EPIC" "$LABEL")

    if [[ -z "$ready" || "$ready" == "null" || "$ready" == "[]" ]]; then
        log_warn "No ready tasks found"
        return
    fi

    echo "$ready" | jq -r '.[] | "[\(.priority)] \(.id): \(.title)"'
}

# Generate the system prompt (static instructions from PROMPT.md)
generate_system_prompt() {
    cat "${PROJECT_DIR}/PROMPT.md"
}

# Generate the task prompt (just the current task details - kept short for stdin)
generate_task_prompt() {
    local task_json="$1"

    # Extract task details
    local task_id=$(echo "$task_json" | jq -r '.id')
    local task_title=$(echo "$task_json" | jq -r '.title')
    local task_type=$(echo "$task_json" | jq -r '.type')
    local task_desc=$(echo "$task_json" | jq -r '.description')
    local task_criteria=$(echo "$task_json" | jq -r '.acceptanceCriteria // [] | join("\n- ")')

    # Generate focused task prompt (minimal - just the task)
    cat <<EOF
## CURRENT TASK

Task ID: ${task_id}
Type: ${task_type}
Title: ${task_title}

Description:
${task_desc}

Acceptance Criteria:
- ${task_criteria}

When complete:
1. Run feedback loops (typecheck, test, lint)
2. Update prd.json: set status to "closed" for ${task_id}
3. Commit: ${task_type}(${task_id}): ${task_title}
4. Append learnings to progress.txt
EOF
}

# Run a single iteration
run_iteration() {
    local prd="${PROJECT_DIR}/prd.json"
    log_debug "Starting iteration"

    # Initialize session if not already initialized
    if ! session_is_initialized; then
        log_debug "Initializing session..."
        if [[ -n "$SESSION_NAME" ]]; then
            session_init --name "$SESSION_NAME"
        else
            session_init
        fi

        if [[ $? -ne 0 ]]; then
            log_warn "Failed to initialize session"
        else
            local session_name
            session_name=$(session_get_name)
            local session_id
            session_id=$(session_get_id)
            log_debug "Session: ${session_name} (${session_id})"
        fi
    fi

    # Initialize logger if not already initialized
    if [[ -z "$(logger_get_file)" ]]; then
        local project_name
        project_name=$(basename "$PROJECT_DIR")
        local session_id
        session_id=$(session_get_id)

        if logger_init "$project_name" "$session_id"; then
            log_debug "Logger initialized: $(logger_get_file)"
        else
            log_warn "Failed to initialize logger"
        fi
    fi

    # Initialize artifacts for this run if not already initialized
    if session_is_initialized; then
        local run_dir
        run_dir=$(artifacts_get_run_dir 2>/dev/null)
        if [[ -n "$run_dir" ]] && [[ ! -f "${run_dir}/run.json" ]]; then
            log_debug "Initializing artifacts..."
            if artifacts_init_run; then
                local artifacts_path
                artifacts_path=$(artifacts_get_run_dir)
                log_debug "Artifacts initialized: ${artifacts_path}"
            else
                log_warn "Failed to initialize artifacts"
            fi
        fi
    fi

    # Initialize git run branch if in a git repository (only if not already initialized)
    if git_in_repo; then
        local current_branch
        current_branch=$(git_get_run_branch 2>/dev/null)
        if [[ -z "$current_branch" ]]; then
            log_debug "Initializing git run branch..."
            local session_name
            session_name=$(session_get_name)
            if git_init_run_branch "$session_name"; then
                local branch_name
                branch_name=$(git_get_run_branch)
                log_info "Git branch: ${branch_name}"
            else
                log_warn "Failed to initialize git run branch"
            fi
        fi
    else
        log_debug "Not in a git repository, skipping git operations"
    fi

    # Check for in-progress tasks first (resume interrupted work)
    # Respects --epic and --label filters
    local current_task
    log_debug "Checking for in-progress tasks..."
    current_task=$(get_in_progress_task "$prd" "$EPIC" "$LABEL")
    log_debug "In-progress query result: ${current_task:0:100}..."

    if [[ -n "$current_task" && "$current_task" != "null" ]]; then
        local task_id=$(echo "$current_task" | jq -r '.id')
        local task_title=$(echo "$current_task" | jq -r '.title')
        local task_type=$(echo "$current_task" | jq -r '.type')

        # Verify the in-progress task is not blocked
        if is_task_ready "$prd" "$task_id"; then
            log_warn "Resuming in-progress task: ${task_id}"
            log_info "  ${task_type}: ${task_title}"
            log_debug "Task JSON: $current_task"
        else
            log_warn "In-progress task ${task_id} is blocked, resetting to open"
            update_task_status "$prd" "$task_id" "open"
            current_task=""
        fi
    fi

    # Find next ready task if no valid in-progress task
    if [[ -z "$current_task" || "$current_task" == "null" ]]; then
        # Find next ready task
        log_debug "No in-progress tasks, finding ready tasks..."
        log_debug "Current _TASK_BACKEND: ${_TASK_BACKEND}"
        local ready_tasks
        ready_tasks=$(get_ready_tasks "$prd" "$EPIC" "$LABEL")
        log_debug "Ready tasks result: ${ready_tasks:0:200}..."

        if [[ -z "$ready_tasks" || "$ready_tasks" == "[]" ]]; then
            # Check if we're done
            local open_count=$(get_remaining_count "$prd")
            log_debug "Open task count: ${open_count}"
            if [[ "$open_count" -eq 0 ]]; then
                log_success "All tasks complete!"
                return 0
            else
                _log_error_console "No ready tasks but ${open_count} tasks not closed. Check dependencies."
                return 1
            fi
        fi

        # Pick highest priority ready task
        current_task=$(echo "$ready_tasks" | jq 'first')
        local task_id=$(echo "$current_task" | jq -r '.id')
        local task_title=$(echo "$current_task" | jq -r '.title')
        local task_type=$(echo "$current_task" | jq -r '.type')
        local task_priority=$(echo "$current_task" | jq -r '.priority')

        log_info "Selected task: ${task_id} [${task_priority}]"
        log_info "  ${task_type}: ${task_title}"
        log_debug "Task JSON: $current_task"

        # Mark as in_progress
        log_debug "Updating task status to in_progress..."
        update_task_status "$prd" "$task_id" "in_progress"
        log_debug "Task status updated"
    fi

    # Check for model: label and set CURB_MODEL if harness is claude
    local harness=$(harness_get)
    if [[ "$harness" == "claude" ]]; then
        local task_model
        task_model=$(echo "$current_task" | jq -r '.labels // [] | .[] | select(startswith("model:")) | split(":")[1]' 2>/dev/null | head -1)
        if [[ -n "$task_model" ]]; then
            log_info "  Model from label: ${task_model}"
            export CURB_MODEL="$task_model"
        fi
    fi

    # Generate prompts
    log_debug "Generating prompts..."
    local system_prompt
    system_prompt=$(generate_system_prompt)
    local task_prompt
    task_prompt=$(generate_task_prompt "$current_task")

    local sys_bytes=$(echo "$system_prompt" | wc -c)
    local task_bytes=$(echo "$task_prompt" | wc -c)
    log_debug "System prompt: ${sys_bytes} bytes (via --append-system-prompt)"
    log_debug "Task prompt: ${task_bytes} bytes (via stdin)"

    # Show prompts in debug mode
    if [[ "$DEBUG" == "true" ]]; then
        echo ""
        log_debug "=== SYSTEM PROMPT ==="
        echo -e "${DIM}$system_prompt${NC}" >&2
        log_debug "=== TASK PROMPT ==="
        echo -e "${DIM}$task_prompt${NC}" >&2
        log_debug "===================="
        echo ""
    fi

    log_info "Running ${harness}..."
    echo ""

    if [[ "$DEBUG" == "true" ]]; then
        # Pre-flight check
        log_debug "Pre-flight: ${harness} version"
        local version_output
        version_output=$(harness_version 2>&1) && log_debug "Version: ${version_output}" || log_debug "WARNING: version check failed"
        log_debug "Binary: $(which ${harness})"
    fi

    # Extract task details for logging
    local task_id=$(echo "$current_task" | jq -r '.id')
    local task_title=$(echo "$current_task" | jq -r '.title')
    local task_priority=$(echo "$current_task" | jq -r '.priority // "normal"')

    # Start task artifacts
    if session_is_initialized; then
        log_debug "Starting task artifacts for ${task_id}..."
        if artifacts_start_task "$task_id" "$task_title" "$task_priority"; then
            local artifacts_path
            artifacts_path=$(artifacts_get_path "$task_id")
            log_debug "Task artifacts: ${artifacts_path}"
        else
            log_warn "Failed to start task artifacts"
        fi
    fi

    # Log task start
    log_task_start "$task_id" "$task_title" "$harness"

    # Run pre-task hooks
    log_debug "Running pre-task hooks..."
    hooks_set_task_context "$task_id" "$task_title"
    hooks_run "pre-task"
    log_debug "Pre-task hooks complete"

    # Run harness with the prompt via abstraction layer
    local start_time=$(date +%s)
    local exit_code=0
    log_debug "Execution start: $(date)"

    if [[ "$DEBUG" == "true" ]]; then
        # Save prompts to temp files for manual testing
        local tmp_sys=$(mktemp)
        local tmp_task=$(mktemp)
        echo "$system_prompt" > "$tmp_sys"
        echo "$task_prompt" > "$tmp_task"
        log_debug "System prompt: ${tmp_sys}"
        log_debug "Task prompt: ${tmp_task}"
        log_debug ">>> Prompts saved for debugging"
        log_debug ""
        log_debug "--- HARNESS START (${harness}) ---"
    fi

    # Invoke harness via abstraction layer
    if [[ "$STREAM" == "true" ]]; then
        log_info "Streaming ${harness} output..."
        harness_invoke_streaming "$system_prompt" "$task_prompt" "$DEBUG"
        exit_code=$?
    else
        harness_invoke "$system_prompt" "$task_prompt" "$DEBUG"
        exit_code=$?
    fi

    if [[ "$DEBUG" == "true" ]]; then
        log_debug "--- HARNESS END (${harness}) ---"

        # Cleanup on success, keep on failure
        if [[ $exit_code -eq 0 ]]; then
            rm -f "$tmp_sys" "$tmp_task"
        else
            log_debug "Keeping prompt files for debugging"
            log_debug "  System: ${tmp_sys}"
            log_debug "  Task: ${tmp_task}"
        fi
    fi

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    log_debug "Execution end: $(date)"
    log_debug "Duration: ${duration} seconds"
    log_debug "Exit code: ${exit_code}"

    # Extract token usage from harness
    local tokens_used=0
    tokens_used=$(harness_get_total_tokens)
    log_debug "Tokens used: ${tokens_used}"

    # Record token usage in budget if budget is initialized
    local budget_remaining=""
    local budget_total=""
    if [[ -f "${TMPDIR:-/tmp}/curb_budget_limit_$$" ]]; then
        log_debug "Recording ${tokens_used} tokens to budget"
        budget_record "$tokens_used"
        budget_remaining=$(budget_remaining)
        budget_total=$(budget_get_limit)
        log_debug "Budget: ${budget_remaining} remaining of ${budget_total}"

        # Check if warning threshold has been crossed
        local warn_at
        warn_at=$(config_get_or "budget.warn_at" "80")
        if budget_check_warning "$warn_at"; then
            : # No warning triggered
        else
            # Warning was just triggered - log it once
            if [[ "$budget_total" -gt 0 ]]; then
                local used=$(budget_get_used)
                local percentage=$((used * 100 / budget_total))
                log_warn "Budget warning: approaching limit (${percentage}% used, ${budget_remaining} tokens remaining)"
            fi
        fi
    fi

    # Log task end with budget information
    if [[ -n "$budget_remaining" && -n "$budget_total" ]]; then
        log_task_end "$task_id" "$exit_code" "$duration" "$tokens_used" "$budget_remaining" "$budget_total"
    else
        log_task_end "$task_id" "$exit_code" "$duration" "$tokens_used"
    fi

    if [[ $exit_code -ne 0 ]]; then
        log_warn "Claude Code exited with code ${exit_code}"
        log_debug "Non-zero exit may indicate: timeout, error, or user interrupt"
        # Log error to structured logger
        log_error "Harness exited with non-zero code" "{\"task_id\": \"$task_id\", \"exit_code\": $exit_code, \"harness\": \"$harness\"}"

        # Run on-error hooks
        log_debug "Running on-error hooks..."
        hooks_set_task_context "$task_id" "$task_title" "$exit_code"
        hooks_run "on-error"
        log_debug "On-error hooks complete"
    else
        log_debug "Claude Code completed successfully"

        # Verify clean state after successful harness run
        log_debug "Checking repository state..."
        if ! state_ensure_clean "$REQUIRE_CLEAN"; then
            log_warn "State check failed: uncommitted changes detected"
            exit_code=1
        else
            log_debug "Repository state is clean"
        fi

        # Run tests if configured
        if [[ $exit_code -eq 0 ]]; then
            log_debug "Running tests if configured..."
            if ! state_run_tests; then
                log_warn "Test run failed"
                exit_code=1
            else
                log_debug "Tests passed or not required"
            fi
        fi
    fi

    # Run post-task hooks (always run, regardless of success/failure)
    log_debug "Running post-task hooks..."
    hooks_set_task_context "$task_id" "$task_title" "$exit_code"
    hooks_run "post-task"
    log_debug "Post-task hooks complete"

    # Capture artifacts after task completion
    if session_is_initialized; then
        log_debug "Capturing task artifacts..."

        # Capture git diff
        if artifacts_capture_diff "$task_id"; then
            log_debug "Captured git diff to changes.patch"
        else
            log_warn "Failed to capture git diff"
        fi

        # Finalize task with status and summary
        local task_status
        if [[ $exit_code -eq 0 ]]; then
            task_status="completed"
        else
            task_status="failed"
        fi

        local summary_text="Task execution completed with exit code ${exit_code}. Duration: ${duration}s. Tokens used: ${tokens_used}."
        if artifacts_finalize_task "$task_id" "$task_status" "$exit_code" "$summary_text"; then
            local artifacts_path
            artifacts_path=$(artifacts_get_path "$task_id")
            log_info "Artifacts saved: ${artifacts_path}"
        else
            log_warn "Failed to finalize task artifacts"
        fi
    fi

    # Commit changes if task was successful and we're in a git repository
    if [[ $exit_code -eq 0 ]] && git_in_repo; then
        log_debug "Committing task changes..."
        if git_commit_task "$task_id" "$task_title" "$summary_text"; then
            log_info "Changes committed to git"

            # Push to remote if --push flag was set
            if [[ "$PUSH" == "true" ]]; then
                log_debug "Pushing branch to remote..."
                if git_push_branch; then
                    log_info "Branch pushed to remote"
                else
                    log_warn "Failed to push branch to remote"
                fi
            else
                log_debug "Skipping push (--push flag not set)"
            fi
        else
            log_warn "Failed to commit changes (this is not an error if there were no changes)"
        fi
    fi

    return $exit_code
}

# Run planning mode
run_planning() {
    local prd="${PROJECT_DIR}/prd.json"
    log_debug "Starting planning mode"

    log_info "Running in planning mode..."

    local plan_prompt
    plan_prompt=$(cat <<'EOF'
Study @specs/* for specifications.
Study @prd.json for the current task backlog.
Study the existing source code.

Your task is to analyze the codebase and update @fix_plan.md:

1. Use subagents to study existing source code and compare against specifications
2. Search for TODO comments, placeholder implementations, and missing functionality
3. Create/update fix_plan.md with a prioritized bullet list of items to implement
4. For each item, note:
   - What needs to be done
   - Which files are affected
   - Dependencies on other items
5. If you discover missing specifications, document them

Think hard. Be thorough. Use many parallel subagents for research.
EOF
)

    if [[ "$DEBUG" == "true" ]]; then
        log_debug "Plan prompt: $(echo "$plan_prompt" | wc -l) lines"
        log_debug "=== PLAN PROMPT ==="
        echo -e "${DIM}$plan_prompt${NC}" >&2
        log_debug "==================="
    fi

    local start_time=$(date +%s)
    log_debug "Execution start: $(date)"

    echo "$plan_prompt" | claude -p --dangerously-skip-permissions

    local exit_code=$?
    local end_time=$(date +%s)
    log_debug "Execution end: $(date), duration: $((end_time - start_time))s, exit: ${exit_code}"
}

# Main loop
run_loop() {
    local max_iterations="${CURB_MAX_ITERATIONS:-$(config_get_or "loop.max_iterations" "100")}"
    local iteration=0

    # Initialize session with optional name override
    if [[ -n "$SESSION_NAME" ]]; then
        session_init --name "$SESSION_NAME"
    else
        session_init
    fi

    if [[ $? -ne 0 ]]; then
        log_warn "Failed to initialize session"
    else
        local session_name
        session_name=$(session_get_name)
        local session_id
        session_id=$(session_get_id)
        log_info "Session: ${session_name} (${session_id})"
    fi

    # Initialize logger with project name and session ID
    local project_name
    project_name=$(basename "$PROJECT_DIR")
    local session_id
    session_id=$(session_get_id)

    if logger_init "$project_name" "$session_id"; then
        log_debug "Logger initialized: $(logger_get_file)"
    else
        log_warn "Failed to initialize logger"
    fi

    # Initialize artifacts for this run
    if artifacts_init_run; then
        local artifacts_path
        artifacts_path=$(artifacts_get_run_dir)
        log_debug "Artifacts initialized: ${artifacts_path}"
    else
        log_warn "Failed to initialize artifacts"
    fi

    # Initialize git run branch if in a git repository
    if git_in_repo; then
        log_debug "Initializing git run branch..."
        local session_name
        session_name=$(session_get_name)
        if git_init_run_branch "$session_name"; then
            local branch_name
            branch_name=$(git_get_run_branch)
            log_info "Git branch: ${branch_name}"
        else
            log_warn "Failed to initialize git run branch"
        fi
    else
        log_debug "Not in a git repository, skipping git operations"
    fi

    log_info "Starting curb loop (max ${max_iterations} iterations)"
    log_debug "Max iterations: ${max_iterations}"
    log_debug "Loop starting at: $(date)"
    echo ""

    # Run pre-loop hooks
    log_debug "Running pre-loop hooks..."
    hooks_set_session_context "$session_id" "$(harness_get)"
    hooks_run "pre-loop"
    log_debug "Pre-loop hooks complete"

    while [[ $iteration -lt $max_iterations ]]; do
        iteration=$((iteration + 1))
        log_info "=== Iteration ${iteration} ==="
        log_debug "--- Iteration ${iteration} start: $(date) ---"

        # Check if all tasks complete
        local prd="${PROJECT_DIR}/prd.json"
        log_debug "Querying remaining tasks..."
        local remaining=$(get_remaining_count "$prd")
        log_debug "Remaining tasks: ${remaining}"

        if [[ "$remaining" -eq 0 ]]; then
            log_success "All tasks complete! Exiting loop."
            show_status
            # Run post-loop hooks
            log_debug "Running post-loop hooks..."
            hooks_run "post-loop"
            log_debug "Post-loop hooks complete"
            return 0
        fi

        # Run single iteration
        log_debug "Calling run_iteration..."
        if ! run_iteration; then
            log_warn "Iteration failed, continuing..."
            log_debug "run_iteration returned non-zero"
        fi

        echo ""
        log_info "Iteration ${iteration} complete. ${remaining} tasks remaining."
        log_debug "--- Iteration ${iteration} end: $(date) ---"
        echo ""

        # Check budget after iteration if budget is initialized
        if [[ -f "${TMPDIR:-/tmp}/curb_budget_limit_$$" ]]; then
            if ! budget_check; then
                local used=$(budget_get_used)
                local limit=$(budget_get_limit)
                echo ""
                log_success "Budget exceeded (used ${used} of ${limit} tokens)"
                log_info "Stopping gracefully due to budget limit"
                show_status
                # Run post-loop hooks
                log_debug "Running post-loop hooks..."
                hooks_run "post-loop"
                log_debug "Post-loop hooks complete"
                return 0
            fi
        fi

        # Brief pause between iterations to allow for interruption
        log_debug "Sleeping 2 seconds before next iteration..."
        sleep 2
    done

    log_warn "Reached max iterations (${max_iterations})"
    log_debug "Loop terminated at: $(date)"
    show_status
    # Run post-loop hooks
    log_debug "Running post-loop hooks..."
    hooks_run "post-loop"
    log_debug "Post-loop hooks complete"
    return 1
}

# Main entry point
main() {
    # Parse global flags (affect entire system) and separate run-specific flags
    local args=()
    for arg in "$@"; do
        if [[ "$arg" == "--debug" || "$arg" == "-d" ]]; then
            DEBUG="true"
            log_debug "Debug mode enabled"
            log_debug "CURB_DIR=${CURB_DIR}"
            log_debug "PROJECT_DIR=${PROJECT_DIR}"
            log_debug "Shell: $SHELL (bash ${BASH_VERSION})"
            log_debug "Date: $(date)"
        elif [[ "$arg" == "--stream" ]]; then
            STREAM="true"
            log_info "Stream mode enabled - showing harness activity"
        elif [[ "$arg" == "--backend="* ]]; then
            BACKEND="${arg#--backend=}"
            export CURB_BACKEND="$BACKEND"
        elif [[ "$arg" == "--backend" ]]; then
            # Next arg is the backend value - handle in next iteration
            _next_is_backend=true
            continue
        elif [[ "${_next_is_backend:-}" == "true" ]]; then
            BACKEND="$arg"
            export CURB_BACKEND="$BACKEND"
            _next_is_backend=false
        elif [[ "$arg" == "--harness="* ]]; then
            HARNESS="${arg#--harness=}"
            export HARNESS
        elif [[ "$arg" == "--harness" ]]; then
            # Next arg is the harness value - handle in next iteration
            _next_is_harness=true
            continue
        elif [[ "${_next_is_harness:-}" == "true" ]]; then
            HARNESS="$arg"
            export HARNESS
            _next_is_harness=false
        else
            # Pass all other args through (including run-specific flags)
            args+=("$arg")
        fi
    done
    unset _next_is_backend
    unset _next_is_harness

    check_deps
    log_debug "Dependencies checked: jq and harness found"

    # Subcommand dispatcher (check for subcommands before legacy flags)
    # Process first non-flag argument as potential subcommand
    local first_arg="${args[0]:-}"

    # Check if first arg is a subcommand (not a flag)
    if [[ -n "$first_arg" && ! "$first_arg" =~ ^- ]]; then
        case "$first_arg" in
            init)
                # Pass remaining args to cmd_init
                cmd_init "${args[@]:1}"
                return $?
                ;;
            run)
                # Run the main loop with remaining args
                cmd_run "${args[@]:1}"
                return $?
                ;;
            status)
                # Show task status
                cmd_status "${args[@]:1}"
                return $?
                ;;
            explain)
                # Explain a task or session
                cmd_explain "${args[@]:1}"
                return $?
                ;;
            artifacts)
                # Manage artifacts
                cmd_artifacts "${args[@]:1}"
                return $?
                ;;
            version)
                # Show version
                cmd_version
                return $?
                ;;
            help)
                # Show help (fall through to --help handling below)
                args=("--help")
                ;;
            *)
                # Unknown subcommand - show error and help
                # (only show error for non-flag arguments)
                if [[ ! "$first_arg" =~ ^- ]]; then
                    _log_error_console "Unknown subcommand: ${first_arg}"
                    echo ""
                    args=("--help")
                fi
                ;;
        esac
    fi

    # Legacy flag parsing (for backwards compatibility)
    case "${args[0]:-}" in
        --status|-s)
            warn_deprecated_flag "--status" "curb status"
            cmd_status "${args[@]:1}"
            ;;
        --ready|-r)
            warn_deprecated_flag "--ready" "curb run --ready"
            cmd_run --ready "${args[@]:1}"
            ;;
        --once|-1)
            warn_deprecated_flag "--once" "curb run --once"
            cmd_run --once "${args[@]:1}"
            ;;
        --plan|-p)
            warn_deprecated_flag "--plan" "curb run --plan"
            cmd_run --plan "${args[@]:1}"
            ;;
        --test|-t)
            log_info "Testing Claude Code invocation..."
            log_debug "Binary: $(which claude)"
            log_debug "Version: $(claude --version 2>&1)"
            echo ""
            log_info "Test 1: Simple echo pipe"
            log_debug "Command: echo 'Say hello' | claude -p"
            if echo "Say hello" | claude -p; then
                log_success "Test 1 passed"
            else
                _log_error_console "Test 1 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 2: Heredoc pipe"
            log_debug "Command: claude -p <<< 'Say goodbye'"
            if claude -p <<< "Say goodbye"; then
                log_success "Test 2 passed"
            else
                _log_error_console "Test 2 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 3: Multi-line prompt"
            local test_prompt="You are a helpful assistant.

Say 'curb test successful' and nothing else."
            log_debug "Command: echo \"\$test_prompt\" | claude -p"
            if echo "$test_prompt" | claude -p; then
                log_success "Test 3 passed"
            else
                _log_error_console "Test 3 failed (exit: $?)"
            fi
            echo ""
            log_success "All tests complete"
            ;;
        --migrate-to-beads)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                _log_error_console "No prd.json found to migrate"
                exit 1
            fi
            log_info "Migrating from prd.json to beads..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "false"
            ;;
        --migrate-to-beads-dry-run)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                _log_error_console "No prd.json found to migrate"
                exit 1
            fi
            log_info "DRY RUN: Showing what would be migrated..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "true"
            ;;
        --dump-prompt)
            validate_project
            local prd="${PROJECT_DIR}/prd.json"
            local current_task
            current_task=$(get_in_progress_task "$prd")
            if [[ -z "$current_task" || "$current_task" == "null" ]]; then
                current_task=$(get_ready_tasks "$prd" | jq 'first')
            fi
            if [[ "$current_task" == "null" || -z "$current_task" ]]; then
                _log_error_console "No tasks available"
                exit 1
            fi
            local sys_file="${PROJECT_DIR}/curb_system_prompt.txt"
            local task_file="${PROJECT_DIR}/curb_task_prompt.txt"
            generate_system_prompt > "$sys_file"
            generate_task_prompt "$current_task" > "$task_file"
            log_success "Prompts dumped:"
            log_info "  System: ${sys_file} ($(wc -c < "$sys_file") bytes)"
            log_info "  Task:   ${task_file} ($(wc -c < "$task_file") bytes)"
            log_info ""
            log_info "To test manually:"
            log_info "  claude -p --append-system-prompt \"\$(cat ${sys_file})\" < ${task_file}"
            ;;
        --help|-h)
            cat <<EOF
curb v${CURB_VERSION} - Claude Under Ralph + Beads

Autonomous AI coding agent that drives harnesses in a loop to complete
tasks from a project backlog.

SUBCOMMANDS:
  curb init [--global] [<dir>]  Initialize project or system
  curb run [<options>]           Run the main loop (default)
  curb status [--json]           Show task progress
  curb explain <task-id>         Show task details
  curb artifacts [<task-id>]     List task outputs
  curb version                   Show version

QUICK START:
  curb init                      Initialize in current directory
  curb run                       Start the main loop
  curb status                    Check progress
  curb run --ready               List tasks to work on

USE --help WITH ANY SUBCOMMAND:
  curb init --help               Init subcommand help
  curb run --help                Run subcommand help
  curb status --help             Status subcommand help
  curb explain --help            Explain subcommand help
  curb artifacts --help          Artifacts subcommand help

EXECUTION MODES:
  curb                           Run continuous loop
  curb run --once                Single iteration then exit
  curb run --ready               List ready tasks
  curb run --plan                Analyze code and plan

CORE FLAGS (work with run):
  --harness <name>               Use specific harness (auto, claude, codex,
                                 gemini, opencode)
  --model <name>                 Claude model (opus, sonnet, haiku)
  --budget <tokens>              Set token budget (e.g., 1000000)
  --name <name>                  Session name for tracking

FILTERING:
  --epic <id>                    Work on tasks in epic
  --label <name>                 Work on tasks with label

RELIABILITY:
  --require-clean                Enforce clean git state
  --no-require-clean             Disable clean state check

DEBUGGING:
  --debug, -d                    Show detailed logs
  --stream                       Stream harness output
  --backend <mode>               Task backend (auto, beads, json)

UTILITY:
  --test                         Test harness invocation
  --dump-prompt                  Export task prompts
  --migrate-to-beads             Convert prd.json to beads
  --migrate-to-beads-dry-run     Preview migration

EXAMPLES:
  curb                           Start main loop
  curb run --once                Single iteration
  curb status                    Show progress
  curb run --ready               List tasks
  curb run --epic backend-v2     Work on epic
  curb run --once --debug        Debug one iteration
  curb run --model sonnet        Use Sonnet model
  curb artifacts curb-018        Get task output
  curb explain curb-018          See task details
  curb init ~/my-project         Initialize project
  curb init --global             Setup system config

ENVIRONMENT VARIABLES:
  CURB_PROJECT_DIR               Project directory (default: pwd)
  CURB_MAX_ITERATIONS            Max loop iterations (default: 100)
  CURB_DEBUG                     Set to "true" for debug
  CURB_BACKEND                   Task backend (auto/beads/json)
  CURB_BUDGET                    Token budget
  CURB_REQUIRE_CLEAN             Clean state enforcement
  HARNESS                        Harness to use
  CURB_MODEL                     Claude model
  CURB_EPIC                      Epic filter
  CURB_LABEL                     Label filter

PROJECT FILES:
  prd.json                       Task backlog (json backend)
  .beads/                        Task tracking (beads backend)
  PROMPT.md                      System prompt template
  AGENT.md                       Build/run instructions
  specs/                         Specification files
  progress.txt                   Progress log
  fix_plan.md                    Issue tracking

LEARN MORE:
  README.md                      Overview and features
  CONFIG.md                      Configuration options
  CONTRIBUTING.md                Development guidelines

INSTALLATION:
  Beads (optional):
    brew install steveyegge/beads/bd
    npm install -g @beads/bd
    go install github.com/steveyegge/beads/cmd/bd@latest
EOF
            ;;
        --version)
            echo "curb v${CURB_VERSION}"
            ;;
        *)
            # Default: run the main loop with all args
            cmd_run "${args[@]}"
            ;;
    esac
}

main "$@"
