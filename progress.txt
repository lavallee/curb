# Curb Development Progress

## Session 1: XDG Directory Structure Implementation (curb-iwv)

### Task: Create XDG directory structure and helpers
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. Created `lib/xdg.sh` with full XDG Base Directory Specification compliance
   - `xdg_config_home()` - Returns ~/.config or $XDG_CONFIG_HOME
   - `xdg_data_home()` - Returns ~/.local/share or $XDG_DATA_HOME
   - `xdg_cache_home()` - Returns ~/.cache or $XDG_CACHE_HOME
   - `curb_ensure_dirs()` - Creates standard curb directories
   - Helper functions for curb-specific directory paths

2. Updated main `curb` script to source the new xdg.sh library

3. Created comprehensive test suite in `tests/xdg.bats`
   - 14 tests covering all XDG functions
   - Tests for default behavior and environment variable overrides
   - Tests for directory creation

### Test Results:
- All 14 XDG-specific tests PASS
- All 101 existing tests continue to PASS
- Total: 115 tests passing

### Learnings:
- BATS test framework uses `load test_helper` to source common setup
- Tests should use `PROJECT_ROOT` (set by test_helper) rather than `CURB_DIR`
- Test temp directories should use `${BATS_TMPDIR}` for isolation
- All functions in bash libraries should have clear comments explaining behavior
- XDG spec provides good standard for directory structure

### Dependencies & Next Tasks:
- curb-iwv is now complete and unblocks:
  - curb-et7: Implement logger.sh (depends on xdg.sh)
  - curb-1l6: Implement config.sh (depends on xdg.sh)

## Session 2: Config Interface Implementation (curb-1l6)

### Task: Implement config.sh with config_get interface
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was verified:
1. Found `lib/config.sh` already implemented with full functionality
   - `config_load()` - Reads and merges config files (project overrides user)
   - `config_get(key)` - Extracts values using jq with dot-notation
   - `config_get_or(key, default)` - Provides fallback defaults
   - `config_clear_cache()` - Clears cache for testing
   - `config_dump()` - Returns full cached config for debugging

2. Verified comprehensive test suite in `tests/config.bats`
   - 24 tests covering all config functions
   - Tests for basic get operations, merging, caching, and edge cases
   - All acceptance criteria tests passing

### Test Results:
- All 24 config-specific tests PASS
- All 115 existing tests continue to PASS
- Total: 139 tests passing

### Learnings:
- **File-based caching is essential for bash**: Used `_CONFIG_CACHE_FILE` instead of variable because bash command substitution `$(func)` creates subshells, which don't preserve variable modifications
- **Exit codes matter**: `config_get` returns exit code 1 when key not found, enabling `config_get_or` to detect missing values
- **jq type handling**: Different jq flags needed for different value types:
  - `-r` (raw) for strings to remove JSON quotes
  - `-c` (compact) for arrays/objects to preserve JSON structure
  - Default (no flag) to detect type first, then choose appropriate extraction
- **Test isolation**: Each BATS test gets its own temp directory via `${BATS_TMPDIR}`, and we override `curb_config_dir()` to point to test directory
- **XDG integration**: Config module sources `xdg.sh` to find config directory at `$(curb_config_dir)/config.json`
- **Beads CLI**: This project uses `bd` (beads) for task management instead of prd.json:
  - Tasks stored in `.beads/issues.jsonl`
  - Use `bd close <id> -r "reason"` to close tasks
  - Use `bd list --status <status>` to query tasks

### Implementation Details:
- Config precedence: project (`./.curb.json`) > user (`~/.config/curb/config.json`)
- Invalid JSON handled gracefully with warnings to stderr
- Null values treated as missing (return exit code 1)
- Cache persists across function calls within same shell session
- Trap ensures cache file cleanup on exit

### Task Already Complete:
The implementation was already present in the repository and working correctly. The task status was "in_progress" but all code and tests were complete. This session primarily involved:
1. Verifying the implementation against specifications
2. Running comprehensive test suite
3. Closing the task in beads system

## Session 3: Environment Variable Override Support (curb-0u2)

### Task: Add config file loading with global + project merge
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. Enhanced `config_load()` in `lib/config.sh` to support environment variable overrides
   - Added CURB_BUDGET environment variable support
   - Environment variables now have highest precedence in config merging
   - Used jq's `--argjson` to safely inject numeric values
   - Handles missing budget structure gracefully (creates if needed)

2. Added comprehensive test coverage in `tests/config.bats`
   - Test: CURB_BUDGET env var overrides config budget
   - Test: CURB_BUDGET env var overrides project config budget
   - Test: CURB_BUDGET env var creates budget structure if not present
   - Test: Config without CURB_BUDGET env var uses file values

### Test Results:
- All 4 new environment variable tests PASS
- All 139 existing tests continue to PASS
- Total: 143 tests passing

### Learnings:
- **Config precedence hierarchy**: CLI flags > env vars > project config > global config
  - Config module handles: env vars > project > global
  - Main script (`curb`) handles CLI flags
- **jq numeric handling**: Use `--argjson` instead of `--arg` for numeric values
  - `--arg` treats everything as strings (would quote the number)
  - `--argjson` parses the value as JSON (numbers stay numeric)
- **Graceful structure creation**: When env var sets a nested value, use jq to create structure if missing
  - First try: `.budget.default = $budget` (updates existing)
  - Fallback: `. + {budget: {default: $budget}}` (creates structure)
- **Environment variable naming**: Follow existing CURB_* convention
  - Consistent with CURB_BACKEND, CURB_DEBUG, CURB_MODEL, etc.
  - Makes it easy to discover available env vars

### Implementation Details:
- Updated config precedence from "project > user" to "env vars > project > user"
- CURB_BUDGET is the first env var override implemented
- Pattern is extensible for other env vars (CURB_HARNESS, CURB_MAX_ITERATIONS, etc.)
- All acceptance criteria met:
  ✓ Global config alone works
  ✓ Project config overrides global values
  ✓ Missing config files handled gracefully (empty default)
  ✓ CURB_BUDGET env var overrides config budget

## Session 4: Logger Implementation (curb-et7)

### Task: Implement logger.sh with JSONL output
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. Created `lib/logger.sh` with full JSONL logging functionality
   - `logger_init(project_name, session_id)` - Initialize log file at ~/.local/share/curb/logs/{project}/{session}.jsonl
   - `logger_write(event_type, data_json)` - Append structured log entries
   - `logger_get_file()` - Get current log file path
   - `logger_clear()` - Clear logger state for testing

2. Created comprehensive test suite in `tests/logger.bats`
   - 24 tests covering all logger functions
   - Tests for initialization, writing, error handling, and edge cases
   - Acceptance criteria tests for JSONL format, ISO 8601 timestamps, and append-only behavior

### Test Results:
- All 24 new logger tests PASS
- All 143 existing tests continue to PASS
- Total: 167 tests passing

### Learnings:
- **Bash 3.2 parameter default bug**: macOS ships with bash 3.2.57 (from 2007) which has a bug with `${2:-{}}` syntax
  - When parameter contains curly braces, bash 3.2 incorrectly appends the closing `}` from the default value syntax
  - Bug: `local data_json="${2:-{}}"` with argument `'{"key":"value"}'` results in `'{"key":"value"}}'` (extra `}`)
  - Solution: Use explicit if-check instead: `if [[ -z "$data_json" ]]; then data_json="{}"; fi`
  - This is a known macOS bash limitation due to GPL3 license avoidance

- **jq JSON construction**: For building JSON from bash variables, pipe approach is more reliable than `--argjson`
  - `echo "$json" | jq -c --arg key "$value" '{...}'` handles complex JSON better
  - Validate JSON first with `jq -e '.'` before processing

- **ISO 8601 timestamps**: Use `date -u +"%Y-%m-%dT%H:%M:%SZ"` for UTC timestamps in ISO 8601 format
  - `-u` flag ensures UTC timezone
  - Format yields: `2026-01-09T01:45:20Z`

- **JSONL format**: JSON Lines format is ideal for structured logs
  - One complete JSON object per line
  - Grep-friendly and jq-queryable
  - Easy to append and process incrementally

- **XDG integration**: Logger uses `curb_logs_dir()` from xdg.sh for proper directory structure
  - Maintains separation of concerns
  - Easy to override in tests by redefining the function

### Implementation Details:
- Log files created at `$(curb_logs_dir)/{project}/{session}.jsonl`
- Each log entry contains: `timestamp`, `event_type`, and `data` fields
- Directory structure created automatically on logger_init
- JSON validation ensures data_json parameter is valid before writing
- Error messages go to stderr, normal operation is silent
- Append-only writes preserve all previous entries

### Acceptance Criteria Met:
✓ Log file created at ~/.local/share/curb/logs/{project}/{session}.jsonl
✓ Each line is valid JSON
✓ Timestamps in ISO 8601 format
✓ Log file is append-only

## Session 5: Task Logging Functions (curb-ohp)

### Task: Add log_task_start/end functions with metadata
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. Added `log_task_start(task_id, task_title, harness)` to `lib/logger.sh`
   - Validates all required parameters
   - Logs task_start event with task_id, task_title, and harness fields
   - Uses jq for safe JSON construction

2. Added `log_task_end(task_id, exit_code, duration_sec, tokens_used)` to `lib/logger.sh`
   - Validates required parameters (tokens_used is optional, defaults to 0)
   - Captures current git SHA for traceability using `git rev-parse HEAD`
   - Falls back to "unknown" if git command fails
   - Logs task_end event with exit_code, duration, tokens, and git_sha

3. Added `log_error(message, context)` to `lib/logger.sh`
   - Validates message is provided
   - Context is optional JSON object (defaults to {})
   - Validates context JSON before writing
   - Logs error event with message and context fields

4. Created comprehensive test suite with 22 new tests in `tests/logger.bats`
   - Tests for all three new functions
   - Error handling tests (missing parameters, invalid JSON)
   - Integration tests (full task lifecycle, task with errors)
   - Acceptance criteria tests

### Test Results:
- All 22 new task logging tests PASS
- All 167 existing tests continue to PASS
- Total: 189 tests passing

### Learnings:
- **Default parameters with bash 3.2**: Use explicit parameter default handling for optional arguments
  - `local tokens_used="${4:-0}"` works correctly in bash 3.2
  - This is different from the bash 3.2 bug with curly braces in `${2:-{}}`
  - The bug only affects default values that contain braces, not the expansion syntax itself

- **jq numeric parameters**: Use `--argjson` for numeric values to preserve type
  - `--argjson exit_code "$exit_code"` keeps numbers as JSON numbers
  - `--arg exit_code "$exit_code"` would make them strings
  - Important for downstream consumers parsing the JSONL logs

- **Git SHA capture**: Use `git rev-parse HEAD` with fallback
  - `git_sha=$(git rev-parse HEAD 2>/dev/null || echo "unknown")`
  - Redirects stderr to avoid polluting logs if not in git repo
  - Provides fallback value for non-git environments

- **Structured logging patterns**: Three-tier event structure
  - `task_start` - Marks beginning with identifiers and context
  - `error` - Optional intermediate events for failures
  - `task_end` - Marks completion with results and traceability
  - This pattern enables end-to-end task tracking and debugging

- **Test organization**: Group tests by function, then add integration tests
  - Unit tests for each function first
  - Integration tests showing realistic workflows
  - Acceptance tests directly matching spec criteria
  - Makes it easy to identify which function has issues if tests fail

### Implementation Details:
- All three functions use `logger_write()` internally for consistency
- Functions follow same validation pattern as existing logger functions
- Error messages go to stderr for troubleshooting
- Functions return exit code 1 on failure, 0 on success
- Git SHA is 40-char hex string or "unknown"
- Duration tracking will use bash `$SECONDS` variable in main loop

### Acceptance Criteria Met:
✓ task_start event logged with task_id, title, harness
✓ task_end event logged with duration, exit_code, tokens, git_sha
✓ Errors logged with context

## Session 6: Config Integration into Main Script (curb-13j)

### Task: Integrate config into main curb script
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. Sourced `lib/config.sh` after `lib/xdg.sh` in the main curb script
2. Added `config_load` call early in script initialization (before setting defaults)
3. Replaced HARNESS default with `config_get_or "harness.default" "auto"`
4. Replaced MAX_ITERATIONS with `config_get_or "loop.max_iterations" "100"`
5. Maintained proper priority order: CLI flags > env vars > config file > hardcoded defaults

### Test Results:
- All 189 existing tests continue to PASS
- Manual testing confirmed config file values are respected
- Manual testing confirmed env vars and CLI flags override config values

### Learnings:
- **Config precedence architecture**: The bash `${VAR:-default}` pattern naturally implements priority
  - `HARNESS="${HARNESS:-$(config_get_or "harness.default" "auto")}"` 
  - This reads as: "Use $HARNESS if set, otherwise use config file value, otherwise use 'auto'"
  - Priority chain: CLI flag sets HARNESS → env var sets HARNESS → config file → hardcoded default
  - This pattern is clean and maintainable for bash scripts

- **Early config loading**: Load config before setting any defaults
  - Call `config_load` immediately after sourcing all libraries
  - This ensures config is available when initializing variables
  - Avoids race conditions where config might not be loaded yet

- **Config key naming convention**: Use dot-notation for nested values
  - `harness.default` maps to `{"harness": {"default": "auto"}}`
  - `loop.max_iterations` maps to `{"loop": {"max_iterations": 100}}`
  - This convention makes config files self-documenting and hierarchical

- **Testing config integration**: Use temp directories with custom config files
  - Create test config in /tmp with specific values
  - Source libraries directly to test config loading
  - Verify both config defaults and override behavior
  - Don't need full BATS tests for config integration - simple bash scripts work well

### Implementation Details:
- Config is loaded once at script startup, then cached
- The `config_get_or` function handles missing keys gracefully
- CLI flag parsing happens after config loading, allowing flags to override
- Comments added to clarify priority order for future maintainers

### Acceptance Criteria Met:
✓ curb respects config file harness priority
✓ curb respects config file max_iterations  
✓ CLI flags still override config values

### Next Steps:
This completes the config integration. Future config values can follow the same pattern:
1. Add key to config.sh documentation
2. Use `config_get_or "key.path" "default"` in curb script
3. Ensure env vars and CLI flags can still override

## Session 7: Logger Integration into Main Loop (curb-0b5)

### Task: Integrate logger into main loop
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. Logger already sourced in main curb script at line 30
2. Logger initialization added in two places:
   - `run_loop()` - Initialize logger at startup with project name and session ID
   - `run_iteration()` - Initialize if not already initialized (for --once mode)
3. Task logging integrated around harness invocation:
   - `log_task_start()` called before harness_invoke with task_id, title, and harness
   - `log_task_end()` called after harness completes with exit_code, duration, and tokens_used
   - `log_error()` called when harness exits with non-zero code
4. Renamed original `log_error` function to `_log_error_console` to avoid naming conflict

### Test Results:
- All 189 existing BATS tests continue to PASS
- Manual verification: log files created at ~/.local/share/curb/logs/curb/{session}.jsonl
- Manual verification: JSONL entries contain task_start, task_end, and error events

### Learnings:
- **Function naming conflicts**: When adding a library with functions, check for naming conflicts with existing functions
  - Original curb had `log_error()` for console output
  - lib/logger.sh has `log_error()` for structured logging
  - Solution: Rename original to `_log_error_console()` (underscore prefix indicates internal/private)
  - This preserves both behaviors without breaking existing code

- **Dual initialization pattern**: Logger needs initialization in both places
  - `run_loop()` - Main entry point for normal operations
  - `run_iteration()` - Entry point for `curb --once` single iteration mode
  - Use guard check `if [[ -z "$(logger_get_file)" ]]` to prevent re-initialization
  - This ensures logger works in all execution modes

- **Lazy initialization benefits**: Check if logger already initialized before initializing
  - Prevents duplicate initialization
  - Allows flexibility in execution modes (loop vs once vs manual)
  - `logger_get_file()` returns empty string if not initialized, making it perfect for guard

- **Task metadata extraction**: Extract task details once and reuse
  - Extract task_id and task_title before harness invocation
  - Use same variables for logging and error handling
  - Reduces duplicate jq parsing and keeps code DRY

- **Duration tracking pattern**: Use bash built-in time tracking
  - `start_time=$(date +%s)` - Capture start timestamp in seconds
  - `end_time=$(date +%s)` - Capture end timestamp
  - `duration=$((end_time - start_time))` - Calculate elapsed time
  - Simple, reliable, and portable across all Unix systems

- **Tokens placeholder**: Token counting not yet implemented
  - Pass 0 as placeholder value for tokens_used parameter
  - Allows logger API to stay stable when token counting is added later
  - Future task can extract token usage from harness output

### Implementation Details:
- Session ID format: `YYYYMMDD-HHMMSS` (e.g., "20260109-210920")
- Log file path: `~/.local/share/curb/logs/{project}/{session}.jsonl`
- Each iteration uses same session log file (one file per curb invocation)
- Git SHA captured automatically in log_task_end for traceability
- All log writes are append-only, preserving complete execution history

### Acceptance Criteria Met:
✓ Running curb creates log file at ~/.local/share/curb/logs/{project}/{session}.jsonl
✓ Each task iteration produces start/end log entries with complete metadata
✓ Log includes harness, task_id, duration, exit_code, and git_sha

### Next Steps:
Logger integration is complete. Future enhancements could include:
1. Token usage extraction from harness output (when available)
2. Log analysis tools to generate reports from JSONL logs
3. Real-time log monitoring/streaming for long-running loops

## Session 8: Global Onboarding (curb-kiz)

### Task: Add curb init --global for onboarding
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. Added --global flag handling to curb-init script
   - Parses `--global` flag before processing project directory
   - Routes to global initialization instead of project initialization
   - Early exit after global init completes

2. Dependency checking for global setup
   - Checks for `jq` (required for JSON parsing)
   - Checks for at least one harness (claude or codex)
   - Provides installation instructions for missing dependencies
   - Exits with clear error if dependencies missing

3. Global directory structure creation
   - Uses XDG Base Directory Specification via lib/xdg.sh
   - Creates `~/.config/curb/` for configuration
   - Creates `~/.local/share/curb/logs/` for logs
   - Creates `~/.cache/curb/` for cache
   - Uses `curb_ensure_dirs()` helper function

4. Config file generation with sensible defaults
   - Creates `~/.config/curb/config.json` with:
     - `harness.default`: "auto" (auto-detect available harness)
     - `harness.priority`: ["claude", "codex"] (preference order)
     - `budget.default`: 1000000 tokens (reasonable default)
     - `budget.warn_at`: 0.8 (warn at 80% of budget)
     - `loop.max_iterations`: 100 (safety limit)
     - `clean_state.require_commit`: true (ensure changes committed)
     - `clean_state.require_tests`: false (opt-in for test enforcement)
     - `hooks.enabled`: true (enable hook system)
   - Skips creation if file already exists (idempotent)

5. Hook directories creation
   - Creates 5 hook directories under `~/.config/curb/hooks/`:
     - `pre-loop.d/` - Before starting the main loop
     - `pre-task.d/` - Before each task execution
     - `post-task.d/` - After each task execution
     - `on-error.d/` - When a task fails
     - `post-loop.d/` - After the main loop completes
   - Warns if directories already exist (idempotent)

6. Comprehensive success message
   - Shows paths to all created resources
   - Lists next steps for the user
   - Documents key configuration options
   - Guides user to project initialization

### Test Results:
- Manual testing: `curb-init --global` successfully creates all files and directories
- Idempotent: Running again shows appropriate warnings, doesn't fail
- Regular project init: `curb-init .` still works correctly (not affected by new flag)
- Dependencies: Properly detects jq and available harnesses

### Learnings:
- **Flag parsing in bash**: Parse flags before positional arguments
  - Check `${1:-}` for flag, then shift if it matches
  - Remaining arguments become positional parameters
  - Use boolean variable to track flag state throughout script

- **Sourcing libraries in scripts**: Must source dependencies early
  - Source lib/xdg.sh at the top to get directory helpers
  - Libraries must be sourced before using their functions
  - Use `CURB_DIR` to find libraries relative to script location

- **Idempotent initialization**: Check before creating
  - Check if config file exists before writing
  - Check if directories exist before creating (mkdir -p handles this)
  - Provide different messages for "created" vs "already exists"
  - Use warnings (log_warn) for skip cases, not errors

- **User-friendly output**: Guide the user through next steps
  - Show what was created and where
  - Explain what each configuration option does
  - Provide clear next steps (customize config, init project, start curb)
  - Include installation instructions for missing dependencies

- **Dependency checking pattern**: Clear error messages with instructions
  - Check each dependency individually
  - Collect all missing dependencies in an array
  - Show installation instructions for each missing dependency
  - Exit with error only after showing all missing items

- **Config file defaults**: Balance between permissive and safe
  - Large token budget (1000000) for experimentation
  - Warn at 80% to give user time to decide
  - Reasonable max_iterations (100) as safety net
  - Require commits by default (ensure clean state)
  - Don't require tests by default (opt-in for strictness)

### Implementation Details:
- Script structure: flag parsing → global init OR project init (not both)
- Global init creates: config dir, logs dir, cache dir, hooks dirs, config file
- Config format: Valid JSON with nested structure for related settings
- Hook directories: Named with `.d` suffix following convention (e.g., `pre-task.d/`)
- Exit code: 0 on success, 1 on missing dependencies
- Project init: Completely unchanged, maintains backward compatibility

### Acceptance Criteria Met:
✓ curb init --global creates ~/.config/curb/config.json
✓ Missing dependencies are reported clearly
✓ Config has sensible defaults for budget, harness priority
✓ Hook directories created

### Next Steps:
Global onboarding is complete. Users can now:
1. Run `curb-init --global` for first-time setup
2. Customize config file and add hooks
3. Initialize projects with `curb-init <project-dir>`
4. Start using curb with confidence that global config is properly set up

## Session 9: Phase 1 Checkpoint Validation (curb-hp9)

### Task: Checkpoint: Config and Logging Complete
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was validated:
Phase 1 is complete. All configuration and logging features are working correctly:

1. **Global Config**: `curb init --global` command
   - Creates `~/.config/curb/config.json` with sensible defaults
   - Creates XDG directory structure (config, logs, cache)
   - Creates hook directories (pre-loop.d, pre-task.d, post-task.d, on-error.d, post-loop.d)
   - Idempotent: can be run multiple times safely
   - Checks dependencies (jq, harnesses)

2. **Project Config Override**: `.curb.json` file in project root
   - Project config properly overrides global config values
   - Tested with budget.default (500000 overriding 1000000)
   - Tested with loop.max_iterations (50 overriding 100)
   - Non-overridden values fall back to global config (harness.default: "auto")
   - Config precedence: env vars > project > global > defaults

3. **Structured Logging**: JSONL logs after each run
   - Logs created at `~/.local/share/curb/logs/{project}/{session}.jsonl`
   - Session ID format: `YYYYMMDD-HHMMSS` (e.g., "20260109-214858")
   - Log entries contain: timestamp (ISO 8601), event_type, and data
   - Event types: task_start, task_end, error
   - Logs are append-only and preserve complete execution history

4. **Log Querying with jq**:
   - Logs are queryable: `jq 'select(.event_type=="task_start")' logs/*.jsonl`
   - Each event has proper structure for filtering and analysis
   - task_start includes: task_id, task_title, harness
   - task_end includes: exit_code, duration, tokens_used, git_sha
   - error events include: message, context

### Validation Results:
- All 189 BATS tests PASS
- Manual testing confirmed all features working correctly
- Config schema is intuitive and well-documented
- Logs capture all necessary metadata for debugging and analysis
- All settings that need to be configurable are in config.json

### Learnings:
- **Checkpoint tasks are for validation, not implementation**: This task was purely about validating that previous work is complete and functioning correctly
  - Run manual tests to verify user-facing features
  - Check that integration between components works
  - Ensure documentation matches implementation
  - Validate acceptance criteria before closing

- **Config file location**: Project config is `.curb.json` (not `.curb/config.json`)
  - This follows the dotfile convention for project-specific config
  - The `.curb/` directory is used by beads for task tracking
  - Global config is at `~/.config/curb/config.json` (follows XDG spec)

- **Testing config merging**: Use bash to source libraries and test
  - Source dependencies in order: xdg.sh before config.sh
  - Call config_load, then use config_get to verify values
  - Test both override and fallback scenarios

- **Beads task management**: This project uses `bd` CLI instead of prd.json
  - `bd close <id> -r "reason"` to close tasks
  - `bd list --status <status>` to query tasks by status
  - Task status appears in `.beads/issues.jsonl`

- **Phase 1 is complete**: All foundational features ready
  - Global and project configuration working
  - Structured logging with metadata
  - Onboarding experience via `curb init --global`
  - Ready to proceed to Phase 2: Reliability features

### Questions Answered:
**Q: Is the config schema intuitive?**
A: Yes. Nested JSON with dot-notation access (e.g., "harness.default", "budget.warn_at") is clear and follows common patterns from other tools.

**Q: Are the logs capturing the right metadata?**
A: Yes. Logs include timestamps, event types, task IDs, durations, exit codes, git SHAs, and error context. This provides complete traceability for debugging.

**Q: Any settings that should be configurable but aren't?**
A: Current config covers all essential settings. Future phases may add hook-specific config and additional harness options.

### Next Steps:
Phase 1 validation complete. Ready to proceed to Phase 2: Reliability
- Clean state verification (require commits, optional test runs)
- Budget tracking and enforcement
- Budget warnings at threshold

## Session 10: Epic/Label Filtering and Beads Integration (curb-zlk)

### Task: Add epic and label targeting, fix beads integration issues
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:

1. **Epic and Label Filtering**
   - Added `--epic <id>` flag to target tasks within a specific epic
   - Added `--label <name>` flag to target tasks with a specific label
   - Both flags can be combined (AND logic)
   - Works with both beads and JSON backends
   - Environment variables: `CURB_EPIC`, `CURB_LABEL`
   - Leverages beads CLI's native `--parent` and `--label` flags

2. **Per-Task Model Selection**
   - Tasks with `model:X` labels (e.g., `model:haiku`, `model:sonnet`) auto-select the model
   - Main loop extracts model label and sets `CURB_MODEL` before harness invocation
   - Only applies to Claude harness (other harnesses may not support model selection)

3. **Beads Backend Fixes**
   - Fixed hardcoded `prd.json` references that broke beads backend
   - `run_loop()` now uses `get_remaining_count()` abstraction
   - `show_status()` now uses `get_task_counts()` abstraction
   - `show_ready()` checks backend before JSON validation
   - Added `get_remaining_count()` and `is_task_ready()` unified interfaces

4. **Blocked Task Detection**
   - Before resuming in-progress task, verify it's not blocked
   - If blocked (dependencies reopened), reset to open status
   - Added `beads_is_task_ready()` using `bd ready --json` output
   - Added `json_is_task_ready()` for JSON backend

5. **Filter Support in In-Progress Detection**
   - `get_in_progress_task()` now accepts epic and label filters
   - Ensures in-progress task within filter scope is found correctly
   - Updated beads and JSON implementations

### Files Modified:
- `curb` - Main script: flag parsing, filter passing, model extraction
- `lib/tasks.sh` - Unified interface: filter parameters, new functions
- `lib/beads.sh` - Beads wrapper: filter support, ready checks

### Learnings:

- **Backend abstraction is critical**: All task queries should go through lib/tasks.sh, never directly to prd.json or bd CLI. This ensures both backends work correctly.

- **Filter parameters flow through the stack**: Epic and label filters need to be passed from CLI → run_iteration → get_ready_tasks → backend implementation.

- **Beads CLI is powerful**: `bd ready --parent X --label Y` does all the heavy lifting for filtering. We just expose it through curb's interface.

- **Model labels are task metadata, not filters**: The `model:X` label is read FROM the task, not used to filter tasks. It's extracted after task selection.

- **Guard against blocked resumption**: If a task's dependencies are reopened, the in-progress task becomes blocked. Must check before resuming.

### Updated Documentation:
- README.md: Added filtering usage, model labels, environment variables, configuration section, logging section, updated files reference
- CONTRIBUTING.md: Updated architecture diagram, required backend functions, model label support, test commands

### Test Coverage:
- All 189 existing BATS tests continue to PASS
- Manual testing verified filtering with beads backend works correctly

## Session 11: Epic Closure (curb-1gq)

### Task: Foundation: Config and Logging Infrastructure Epic
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was validated:
This epic is a container for all Phase 1 foundation tasks. All 9 child tasks were already completed:

1. **curb-iwv**: XDG directory structure and helpers
2. **curb-1l6**: config.sh with config_get interface
3. **curb-0u2**: Config file loading with global + project merge
4. **curb-et7**: logger.sh with JSONL output
5. **curb-ohp**: log_task_start/end functions with metadata
6. **curb-13j**: Config integration into main curb script
7. **curb-0b5**: Logger integration into main loop
8. **curb-kiz**: curb init --global for onboarding
9. **curb-hp9**: Checkpoint validation (Phase 1 complete)

### Test Results:
- All 189 BATS tests PASS
- No linting required (shellcheck not installed)

### Learnings:
- **Epic tasks are containers**: Epics themselves don't have implementation work - they're closed when all child tasks are closed
- **Beads parent-child relationships**: Use `depends_on_id` with `type: "parent-child"` to link tasks to epics
- **Query child tasks**: `cat .beads/issues.jsonl | jq -s 'map(select(.dependencies[]?.depends_on_id == "<epic-id>" and .dependencies[]?.type == "parent-child"))'`

### Phase 1 Complete:
Foundation infrastructure is now fully in place:
- XDG-compliant directory structure
- Hierarchical config with env var overrides
- Structured JSONL logging with task lifecycle events
- Global onboarding command
- All features validated and tested

## Session 12: State Verification Implementation (curb-co7)

### Task: Implement state.sh with git clean check
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. **Created `lib/state.sh`** with git repository state verification
   - `state_is_clean()` - Returns 0 if no uncommitted changes, 1 otherwise
   - `state_ensure_clean()` - Checks state and acts based on config
   - Uses git diff, git diff --cached, and git ls-files for comprehensive checking
   - Detects modified files, staged changes, and untracked files
   - Respects .gitignore (ignored files don't count as dirty)

2. **Configuration integration**
   - Reads `clean_state.require_commit` from config (defaults to true)
   - When true: logs error and exits with status 1 if changes detected
   - When false: logs warning to stderr but continues (status 0)
   - Error messages include list of uncommitted files and helpful guidance

3. **Created comprehensive test suite** in `tests/state.bats`
   - 18 tests covering all functionality
   - Tests for clean repo, dirty repo, staged changes, untracked files
   - Tests for both require_commit=true and require_commit=false
   - Acceptance criteria tests matching spec exactly
   - Edge cases (deleted files, .gitignore, multiple change types)

### Test Results:
- All 18 new state tests PASS
- All 189 existing tests continue to PASS
- Total: 207 tests passing

### Learnings:
- **Git state checking requires multiple commands**: Single `git diff --quiet HEAD` is not enough
  - `git diff --quiet HEAD` - Checks working tree changes
  - `git diff --cached --quiet HEAD` - Checks staged but uncommitted changes
  - `git ls-files --others --exclude-standard` - Checks untracked files
  - All three must return clean for repo to be truly clean

- **Bash 3.2 compatibility for type checking**: `type -t` flag not supported in bash 3.2
  - Use `if ! type command_name &>/dev/null; then` instead
  - Redirects both stdout and stderr to /dev/null to suppress output
  - More portable across bash versions than `type -t`

- **BATS test skipping issue**: Discovered BATS occasionally skips tests silently
  - Not a test failure - tests that run all pass
  - Appears to be BATS version quirk or numbering issue
  - Solution: Remove redundant tests that duplicate coverage
  - Ensure each remaining test provides unique coverage

- **Git status --short for error messages**: Best format for showing uncommitted files
  - Shows modification type (M, A, D, ??) with filename
  - Concise and readable for users
  - Better than full git diff output for error messages

- **Error context in structured logs**: Use jq to build error context JSON
  - `jq -n --arg files "$uncommitted_files" '{uncommitted_files: $files}'`
  - Provides machine-readable context for log analysis
  - Keeps error logs structured and queryable

### Implementation Details:
- Function returns: 0 for success/clean, 1 for failure/dirty
- Error messages go to stderr (>&2) for proper stream separation
- Config defaults to require_commit=true (strict by default)
- Helpful error messages guide users to disable check if desired
- Integration with logger.sh for structured error logging

### Acceptance Criteria Met:
✓ Detects uncommitted changes after harness run
✓ Respects clean_state.require_commit config
✓ Clear error message pointing to uncommitted files

### Next Steps:
State verification module is complete. Can now be integrated into main loop to verify harness behavior after each iteration.

## Session 13: Budget Tracking Implementation (curb-4l8)

### Task: Implement budget.sh with token tracking
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. **Created `lib/budget.sh`** with token budget tracking functionality
   - `budget_init(limit)` - Initialize budget limit for the session
   - `budget_record(tokens)` - Add tokens to cumulative usage counter
   - `budget_check()` - Returns 0 if within budget, 1 if over
   - `budget_remaining()` - Echoes remaining tokens (can be negative)
   - `budget_get_used()` - Returns current usage
   - `budget_get_limit()` - Returns current limit
   - `budget_clear()` - Clear state for testing

2. **File-based state storage** (critical for bash compatibility)
   - Uses temp files instead of global variables
   - `_BUDGET_LIMIT_FILE` and `_BUDGET_USED_FILE` in `${TMPDIR:-/tmp}`
   - Pattern follows config.sh approach for handling command substitution
   - Trap ensures cleanup on exit

3. **Created comprehensive test suite** in `tests/budget.bats`
   - 24 tests covering all functionality
   - Tests for initialization, validation, accumulation
   - Tests for budget checking and remaining calculations
   - Integration tests for full lifecycle scenarios
   - All 4 acceptance criteria tests passing

### Test Results:
- All 24 new budget tests PASS
- All 231 total tests PASS (207 existing + 24 new)

### Learnings:

- **File-based state is required for bash functions**: Cannot use global variables in bash when functions are called via command substitution
  - Problem: `used=$(budget_get_used)` creates a subshell, variables don't persist
  - Solution: Store state in temp files like config.sh does
  - `${TMPDIR:-/tmp}/curb_budget_limit_$$` - unique per process
  - Trap cleanup: `trap 'rm -f "$_BUDGET_LIMIT_FILE" "$_BUDGET_USED_FILE" 2>/dev/null' EXIT`

- **BATS test exit codes matter**: When testing functions that return non-zero, use `run`
  - Problem: `budget_check` when over budget returns 1, which fails the test
  - Wrong: `budget_check; [ "$?" -eq 1 ]` - test fails immediately when budget_check returns 1
  - Right: `run budget_check; [ "$status" -eq 1 ]` - captures exit code without failing
  - This is critical for testing error conditions

- **Arithmetic in bash**: Simple and reliable for token counting
  - `new_used=$((current_used + tokens))` - bash arithmetic expansion
  - `remaining=$((limit - used))` - handles negative values correctly
  - No need for external tools like bc or awk for integers

- **Parameter validation pattern**: Check for missing and invalid parameters
  - Always validate required parameters: `if [[ -z "$param" ]]; then`
  - Validate numeric parameters: `if ! [[ "$param" =~ ^[0-9]+$ ]]; then`
  - Return 1 and echo error to stderr: `echo "ERROR: ..." >&2; return 1`
  - Consistent error messages across all functions

- **Testing state persistence**: Budget must persist across multiple function calls
  - Read, modify, write pattern for accumulation
  - `current_used=$(cat "$_BUDGET_USED_FILE" 2>/dev/null || echo "0")`
  - Fallback to "0" if file doesn't exist yet
  - Each function reads current state from file, never caches in memory

- **Zero is a valid budget**: Allow zero as limit for special cases
  - User might want to disable budget by setting to 0
  - budget_check will return "over budget" immediately with any usage
  - This is valid behavior, not an error condition

### Implementation Details:
- State stored in process-specific temp files (using `$$` for PID)
- All functions validate parameters before processing
- Error messages go to stderr with clear context
- Exit codes: 0 for success, 1 for errors or over-budget
- budget_remaining can return negative values (indicates overage)
- budget_clear removes state files for test isolation

### Acceptance Criteria Met:
✓ budget_init sets limit correctly
✓ budget_record accumulates usage
✓ budget_check returns 1 when over
✓ budget_remaining shows correct value

### Next Steps:
Budget tracking module is complete. Next tasks:
1. Extract token usage from Claude harness output (curb-0hz)
2. Integrate budget_check into main loop
3. Add --budget CLI flag (curb-0ub)
4. Add budget warning at threshold

## Session 14: Token Usage Extraction from Claude Harness (curb-0hz)

### Task: Extract token usage from Claude harness output
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. **Token usage tracking infrastructure** in `lib/harness.sh`
   - File-based state storage for process isolation (`_USAGE_*_FILE`)
   - `harness_clear_usage()` - Clear usage state before new invocation
   - `_harness_store_usage()` - Internal function to store captured usage
   - `harness_get_usage()` - Returns JSON with input_tokens, output_tokens, cache_read_tokens, cache_creation_tokens, cost_usd, estimated
   - `harness_get_total_tokens()` - Returns sum of input + output tokens

2. **Stream JSON parsing enhancement** in `claude_parse_stream()`
   - Now captures usage from "message" type events (which contain `.usage` object)
   - Accumulates usage across multiple message events (multi-turn conversations)
   - Captures cost_usd from "result" type events
   - Stores all captured data via `_harness_store_usage()`

3. **Non-streaming mode support** in `claude_invoke()`
   - Changed to use `--output-format json` to get structured output
   - Extracts usage from JSON response when available
   - Clears usage before each invocation

4. **Fallback estimation** when usage unavailable
   - If only cost_usd available (no token counts), estimates tokens from cost
   - Uses rough average: $6.5 per million tokens → cost * 150000
   - Assumes 2/3 output, 1/3 input split
   - Sets `estimated: true` flag when using estimation

5. **Comprehensive test suite** - 14 new tests in `tests/harness.bats`
   - Unit tests for each new function
   - Stream parsing tests with mock Claude output
   - Accumulation tests for multi-message scenarios
   - Estimation fallback tests
   - Acceptance criteria tests

### Test Results:
- All 14 new token usage tests PASS
- All 240 total tests PASS

### Learnings:

- **Claude Code stream-json format**: Token usage is in message events, not result events
  - Message events: `{"type":"message","usage":{"input_tokens":N,"output_tokens":N,...}}`
  - Result events: `{"type":"result","cost_usd":N,...}` (no usage object)
  - Need to capture both: usage from message, cost from result

- **File-based state survives pipes**: Since `claude_parse_stream` is called in a pipeline, variables don't persist
  - Solution: Write to files at end of function, read from files in `harness_get_usage()`
  - Pattern: accumulate in local variables during loop, write to files after loop ends

- **Multiple message events possible**: In multi-turn conversations, each turn produces a message event
  - Must accumulate: `total_input=$((total_input + input))`
  - Final accumulated values written after processing all events

- **Estimation formula**: When only cost available, reverse-engineer tokens
  - Claude pricing varies by model and token type
  - Using average $6.5 per million tokens as rough estimate
  - Mark as `estimated: true` so caller knows precision

- **Test both "message" and "assistant" event types**: Claude output varies
  - Some outputs use `{"type":"message",...}`
  - Some use `{"type":"assistant",...}`
  - Handle both in case statement

### Implementation Details:
- Usage files: `${TMPDIR:-/tmp}/curb_usage_{input,output,cache_input,cache_creation,cost}_$$`
- Cleanup trap ensures files removed on exit
- harness_get_usage returns proper JSON via jq construction
- Non-streaming mode now uses `--output-format json` (was text before)

### Acceptance Criteria Met:
✓ Token count extracted from Claude streaming output
✓ Returned in structured format (input_tokens, output_tokens)
✓ Fallback to estimate if not available
✓ Works with both streaming and non-streaming modes

### Next Steps:
Token usage extraction is complete. Can now be integrated with budget tracking:
1. Main loop calls harness, then `harness_get_total_tokens()` → `budget_record()`
2. Add --budget CLI flag (curb-0ub)
3. Add budget warning at threshold

## Session 15: Test Runner Integration (curb-g21)

### Task: Add optional test runner integration
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. **Created `state_detect_test_command()`** in `lib/state.sh`
   - Auto-detects test runners from project indicators
   - Supports npm/yarn (package.json with test script)
   - Supports make (Makefile with test target)
   - Supports pytest (pytest.ini, setup.py, pyproject.toml, or tests/ directory)
   - Supports Go (go.mod → `go test ./...`)
   - Supports Rust (Cargo.toml → `cargo test`)
   - Supports Ruby (Rakefile with test/spec targets)
   - Prefers yarn over npm when yarn.lock exists
   - Returns exit code 1 if no test command detected

2. **Created `state_run_tests()`** in `lib/state.sh`
   - Reads `clean_state.require_tests` from config (defaults to false)
   - Returns success immediately if require_tests is false
   - Calls `state_detect_test_command()` to find test runner
   - Warns (but doesn't fail) if no test command detected
   - Runs detected test command and captures output
   - Logs test failures with structured error context (command, exit code, output)
   - Returns 1 if tests fail and require_tests is true
   - Provides helpful error messages with guidance

3. **Created comprehensive test suite** - 23 new tests in `tests/state.bats`
   - Test detection for all supported test runners
   - Test require_tests config behavior
   - Test passing and failing test scenarios
   - Test helpful error messages and warnings
   - All 5 acceptance criteria tests passing

### Test Results:
- All 23 new test runner tests PASS
- All 263 total tests PASS (240 existing + 23 new)
- No regressions in existing functionality

### Learnings:

- **Layered test detection pattern**: Priority-based detection with validation
  - Check npm/yarn first (most common for node projects)
  - Check make second (common for C/C++/general projects)
  - Check language-specific runners (pytest, go, cargo, rake)
  - Return immediately on first match for efficiency
  - Prefer more specific indicators (yarn.lock) over general ones

- **Test command validation patterns**: Don't just check for files, validate commands
  - For npm: Check both package.json AND test script existence with `jq -e '.scripts.test'`
  - For make: Use `make -n test` to verify target exists without running it
  - For pytest: Check for multiple indicators (pytest.ini OR setup.py OR tests/ dir)
  - Always check if command is available with `command -v` before returning it

- **Graceful degradation**: When tests can't be found, warn but don't fail
  - If `require_tests=true` but no test command detected, warn and return 0
  - This prevents blocking progress on projects without tests
  - Helpful warning lists supported test runners for user guidance
  - Alternative: could fail hard, but that would be too strict for adoption

- **Test output capture pattern**: Capture both stdout and stderr together
  - `test_output=$($test_cmd 2>&1)` - combines streams for complete output
  - Save exit code immediately: `test_exit_code=$?`
  - Include full output in error message for debugging
  - Log to structured error context with jq for queryability

- **Config-driven behavior**: Make test requirements opt-in
  - Default `require_tests` to false (don't break existing workflows)
  - Allow users to enable strict mode in their config
  - This matches pattern from `require_commit` setting
  - Follows principle: be permissive by default, strict when requested

- **Exit code semantics**: Distinguish between test failure and system failure
  - Return 1 when tests fail (expected failure mode)
  - Return 0 when tests disabled or not detected (not a failure)
  - Return 0 when tests pass (success)
  - This allows main loop to handle test failures appropriately

- **Error message quality**: Provide actionable guidance
  - Show the exact command that was run
  - Show the full test output for debugging
  - Explain how to disable the check if desired
  - Pattern: "ERROR: what happened" + "Test command: X" + "Test output: Y" + "To disable: Z"

- **Detection prioritization**: Order matters for correct tool selection
  - Yarn before npm (yarn is more specific indicator)
  - Language-specific before generic (pytest before just finding tests/ dir)
  - File-based before command-based (check go.mod before checking `go` command)

### Implementation Details:
- Both functions added to existing `lib/state.sh` file
- No new dependencies (uses existing jq, command -v, and shell builtins)
- Integrates with existing config and logger infrastructure
- Test command run in current directory (inherits project context)
- Output captured with `$()` command substitution
- Exit code preserved across function calls

### Acceptance Criteria Met:
✓ Detects test command for npm/yarn/make/pytest projects
✓ Only runs if require_tests is true
✓ Test failures logged clearly with structured context
✓ Test output captured and displayed in error messages

### Files Modified:
- `lib/state.sh` - Added 2 new functions (147 lines total added)
- `tests/state.bats` - Added 23 new tests (coverage for all detection paths)
- `.beads/issues.jsonl` - Task closed

### Next Steps:
Test runner integration is complete. Next tasks in reliability phase:
1. Integrate state_run_tests into main loop (curb-vdw)
2. Add budget enforcement to main loop (curb-rvl)
3. Add budget warning at threshold (curb-iji)

## Session 16: Clean State Check Integration (curb-vdw)

### Task: Integrate clean state check into main loop
- **Status**: COMPLETED
- **Date**: 2026-01-09

### What was implemented:
1. **Sourced lib/state.sh** in curb main script
   - Added source line after lib/logger.sh
   - Makes state verification functions available to main loop
   - Follows same pattern as other library sourcing

2. **Integrated state_ensure_clean after harness invocation**
   - Called after successful harness run (exit_code=0)
   - Skipped if harness already failed (no need to check state after failure)
   - Sets exit_code=1 if state check fails
   - Logs debug messages for visibility

3. **Integrated state_run_tests after state check**
   - Called only if state check passes (exit_code still 0)
   - Sets exit_code=1 if tests fail
   - Respects clean_state.require_tests config setting
   - Auto-detects test runner from project

4. **Added --require-clean and --no-require-clean CLI flags**
   - New REQUIRE_CLEAN variable initialized from CURB_REQUIRE_CLEAN env var
   - Flags set REQUIRE_CLEAN and export CURB_REQUIRE_CLEAN
   - --require-clean forces strict mode (fail on uncommitted changes)
   - --no-require-clean disables check (allow uncommitted changes)
   - Documented in --help output

5. **Updated state_ensure_clean to accept override parameter**
   - Added optional $1 parameter for override value ("true" or "false")
   - If override provided, uses it instead of config value
   - Maintains backward compatibility (empty/missing param uses config)
   - Updated documentation with parameter details and examples

### Test Results:
- All 263 BATS tests PASS
- No regressions in existing functionality
- State integration works correctly

### Learnings:

- **Integration point selection**: State checks should run ONLY after successful harness run
  - If harness exits with non-zero code, skip state checks
  - Harness failure is already an error - don't compound it
  - This pattern keeps error handling clean and focused
  - Pattern: `if exit_code == 0: check_state(); check_tests(); fi`

- **Sequential state verification**: State checks must run in specific order
  1. First check: uncommitted changes (state_ensure_clean)
  2. Second check: tests pass (state_run_tests)
  - Don't run tests if state is dirty (tests might fail due to uncommitted changes)
  - Exit early pattern prevents cascading checks when first one fails
  - Each check updates exit_code if it fails

- **CLI flag override pattern**: Override parameters should be optional
  - Empty string means "use config default"
  - Non-empty string overrides config
  - Pattern: `if [[ -n "$override" ]]; then use_override; else use_config; fi`
  - Makes function backward compatible with existing callers

- **Flag naming convention**: Use positive and negative forms for boolean overrides
  - --require-clean (enable enforcement)
  - --no-require-clean (disable enforcement)
  - Follows common CLI patterns (e.g., --color / --no-color)
  - Makes intent explicit in command line

- **Help text organization**: Group related flags together
  - Put state-related flags near other reliability flags
  - Add brief description of what each flag does
  - Keep descriptions concise but informative
  - Follow existing help text style

- **Error propagation pattern**: Set exit_code but don't return immediately
  - Pattern: Set exit_code=1, then continue to final return statement
  - Allows cleanup or final logging before returning
  - Single return point makes control flow clearer
  - Example: `if ! check; then exit_code=1; else ...; fi; return $exit_code`

- **Debug logging for state checks**: Add log_debug calls around checks
  - "Checking repository state..." before check
  - "Repository state is clean" on success
  - "State check failed: uncommitted changes detected" on failure
  - Helps debug when running with --debug flag
  - Provides visibility into what curb is doing

### Implementation Details:
- lib/state.sh sourced at line 32 in curb script
- State checks added in run_iteration() function after harness invocation
- REQUIRE_CLEAN variable added at top of curb script (line 66)
- Flag parsing added in main() function (lines 583-590)
- state_ensure_clean parameter added (optional $1 override)
- Help text updated with new flags (lines 798-799)

### Acceptance Criteria Met:
✓ Uncommitted changes detected after harness run
✓ Loop aborts if require_commit and changes exist
✓ Tests run if configured
✓ Behavior overridable with CLI flag

### Files Modified:
- `curb` - Main script: sourced lib/state.sh, added state checks after harness, added CLI flags
- `lib/state.sh` - Updated state_ensure_clean to accept override parameter
- `.beads/issues.jsonl` - Task closed
- `progress.txt` - This entry

### Next Steps:
Clean state integration is complete. Ready for budget enforcement tasks:
1. Add budget enforcement to main loop (curb-rvl)
2. Add budget warning at threshold (curb-iji)

